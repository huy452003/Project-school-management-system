* new 26/10/2025

###( Guide Note 154)###
* Giải pháp bảo vệ API khi bị flood:
    - Khái niệm "flood" (DDoS/traffic spike): lượng request tăng đột biến trong thời gian ngắn
    làm nghẽn tài nguyên.
    - Đặt API Gateway/Reverse Proxy (ví dụ: Spring Cloud Gateway, Kong, Nginx) phía trước để:
       +  Rate limiting (giới hạn tốc độ): áp dụng thuật toán token bucket hoặc sliding window
       để chỉ cho phép X request trong mỗi đơn vị thời gian.
       +  Throttling (làm chậm): trì hoãn hoặc giảm tốc các request vượt ngưỡng thay vì đóng hoàn toàn.
       +  IP blocking/Geo blocking: chặn các địa chỉ IP hoặc vùng địa lý bất thường.
    - Áp dụng Bulkhead pattern: chia nhỏ tài nguyên (thread pool, connection pool) cho từng
    nhóm tác vụ. Nếu một nhóm bị đầy, nhóm khác vẫn hoạt động.
    - Circuit Breaker + TimeLimiter (Resilience4j):
       +  Circuit Breaker: theo dõi lỗi/timeout. Khi vượt ngưỡng sẽ "mở" để từ chối request
       và gọi fallback.
       +  TimeLimiter: giới hạn thời gian thực thi; nếu quá hạn sẽ hủy call để tránh treo thread.
    - Retry có kiểm soát: dùng `@Retryable` với backoff (tăng thời gian giữa các lần retry)
    và giới hạn số lần để tránh gây thêm áp lực.
    - Message queue (Kafka, RabbitMQ) hoặc hàng đợi nội bộ: nhận request rồi xử lý bất đồng bộ
    qua worker, giúp API trả lời nhanh hơn (202 Accepted) thay vì xử lý ngay.
    - Cache (Redis, Caffeine):
       +  Cache layer trước database để trả lại dữ liệu cũ nhanh chóng.
       +  Response cache/fallback cache: lưu response gần nhất đề phòng downstream chết.
    - Web Application Firewall (WAF): lớp bảo vệ phân tích lưu lượng, chặn bot, SQL injection,
    request bất thường (AWS WAF, Cloudflare, ModSecurity).
    - CDN (Content Delivery Network): với API tĩnh (GraphQL schema, public data) có thể cache
    toàn cầu giảm tải.
    - Load shedding: khi hệ thống quá tải, ưu tiên request quan trọng, trả lỗi 503 cho request
    ít quan trọng để bảo vệ lõi.

  * Khôi phục nhanh khi service die:
    - Autoscaling & Rolling restart:
       +  Kubernetes Horizontal Pod Autoscaler: tự tăng số pod khi CPU/RPS cao, giảm khi rảnh.
       +  Liveness/Readiness probe: nếu pod chết, kubelet tự khởi động lại; readiness đảm bảo chỉ
       nhận traffic khi đã sẵn sàng.
    - Blue-Green/Canary Deploy: chạy song song phiên bản mới và cũ. Nếu sự cố, quay lại phiên bản
    ổn định tức thì.
    - Immutable infrastructure: build container image (Docker) bất biến, deploy tự động qua CI/CD
    (Jenkins, GitHub Actions) để phục hồi nhanh.
    - Externalized state:
       +  Database/Redis/S3 lưu trạng thái, tránh mất dữ liệu khi pod chết.
       +  Khi khởi động lại thực hiện warm-up (nạp cache, tải cấu hình), replay queue/outbox để
       đồng bộ dữ liệu.
    - Observability:
       +  Metrics (Prometheus/Grafana), logs (ELK, Loki), tracing (Zipkin, Jaeger) giúp phát hiện lỗi,
       thời gian phản hồi, tỷ lệ lỗi.
       +  Alerting: cảnh báo qua Slack, Email, PagerDuty ngay khi có spike hoặc pod down.
    - Chaos Engineering (nâng cao): dùng Chaos Monkey hoặc kube-monkey để thử nghiệm service die
    đột ngột, đảm bảo quy trình tự hồi phục hoạt động.
    - Runbook: tài liệu từng bước khôi phục, liên hệ, lệnh cần chạy; team on-call dựa vào đó để xử lý
    nhanh.


###( Guide Note 159)###
* Vấn đề N+1 Query:
  - Định nghĩa: Khi có N entity cha, và mỗi entity cha có quan hệ với entity con (OneToMany, ManyToMany)
    Nếu sử dụng FetchType.LAZY và truy cập relationship trong vòng lặp -> sẽ phát sinh N+1 queries
    + 1 query để lấy N entity cha
    + N queries để lấy entity con cho mỗi entity cha
    + Vấn đề N+1 Query - Pattern gây ra:

  - Pattern chính xác: "Trong vòng lặp, dùng 1 entity để find N entity có quan hệ với nó"
  - Cụ thể:
    1. Query 1 lần để lấy N entity cha: findAll(), findByStatus(), etc.
    2. Loop qua N entity cha
    3. Trong loop, mỗi lần truy cập relationship (getCourses(), getStudents(), etc.) 
       → Trigger 1 query mới để lấy entity con
    4. Kết quả: 1 query (lấy N cha) + N queries (lấy con cho mỗi cha) = N+1 queries
    
  - Ví dụ cụ thể:
    // BƯỚC 1: Query 1 lần lấy N entity cha
    List<Teacher> teachers = teacherRepo.findAll();  
    // SQL: SELECT * FROM teachers  (1 query)
    
    // BƯỚC 2: Loop qua N teachers
    for (Teacher teacher : teachers) {  // Giả sử có 10 teachers
        // BƯỚC 3: Trong loop, truy cập relationship
        List<Course> courses = teacher.getCourses();  
        // SQL: SELECT * FROM courses WHERE teacher_id = ?  (10 queries - 1 cho mỗi teacher)
        // Query 1: WHERE teacher_id = 1
        // Query 2: WHERE teacher_id = 2
        // ...
        // Query 10: WHERE teacher_id = 10
    }
    // Tổng: 1 + 10 = 11 queries (N+1 problem với N=10)
    
  - Điều kiện để xảy ra N+1:
    + Entity có relationship với FetchType.LAZY (mặc định)
    + Query lấy nhiều entity cha (findAll, findByStatus, etc.)
    + Trong vòng lặp, truy cập relationship của entity cha
    + Relationship chưa được fetch trước (không dùng JOIN FETCH, Entity Graph, etc.)
    
  - Tại sao gọi là N+1?
    + 1 query đầu tiên: lấy N entity cha (findAll() → SELECT * FROM teachers)
    + N queries tiếp theo: trong vòng lặp, mỗi entity cha trigger 1 query để lấy entity con 
      (teacher.getCourses() → SELECT * FROM courses WHERE teacher_id = ?)
      → Với N=10 teachers → có 10 queries riêng biệt
    + Tổng = 1 + N = N+1 queries
    + Ví dụ: N=10 → 1 + 10 = 11 queries (thay vì chỉ 1 query với JOIN)
    
  - Giải pháp:
    1. Entity Graph (Spring Data JPA):
       @EntityGraph(attributePaths = {"courses"})
       @Query("SELECT t FROM Teacher t")
       List<Teacher> findAllWithCourses();
       // Hoặc:
       @EntityGraph(attributePaths = {"courses"})
       List<Teacher> findAll();

      * Ưu điểm:
        - Linh hoạt: có thể reuse method findAll() với/không Entity Graph
        - Dễ đọc, dễ maintain: annotation rõ ràng
        - Tích hợp tốt với Spring Data JPA
        - Có thể combine nhiều relationships: @EntityGraph(attributePaths = {"courses", "students"})
        - Có thể dùng với pagination (Pageable)
      * Nhược điểm:
        - Chỉ dùng được với Spring Data JPA (không dùng được với EntityManager trực tiếp)
      * Khi nào dùng: Khi dùng Spring Data JPA và cần linh hoạt fetch relationships

      * Tại sao @EntityGraph ngăn được N+1?
         - Cơ chế hoạt động:
           1. @EntityGraph báo cho Hibernate/JPA biết: "Khi query Teacher, cũng fetch luôn courses"
           2. Hibernate sẽ tự động thêm LEFT JOIN vào SQL query
           3. Thay vì query riêng biệt, tất cả dữ liệu được lấy trong 1 query duy nhất
         
         - SQL được generate:
           KHÔNG dùng @EntityGraph (N+1):
             Query 1: SELECT * FROM teachers
             Query 2: SELECT * FROM courses WHERE teacher_id = 1
             Query 3: SELECT * FROM courses WHERE teacher_id = 2
             ... (N queries)
           
           CÓ dùng @EntityGraph (1 query):
             SELECT t.*, c.* 
             FROM teachers t 
             LEFT JOIN courses c ON t.id = c.teacher_id
             → Tất cả dữ liệu được lấy trong 1 query, Hibernate tự động map vào entities
         
         - Cơ chế bên trong:
           + @EntityGraph tạo một "fetch plan" cho Hibernate
           + Hibernate thay đổi SQL query từ SELECT t.* thành SELECT t.*, c.* với JOIN
           + Khi map kết quả, Hibernate tự động populate courses vào mỗi Teacher entity
           + Tất cả courses đã được load sẵn trong memory → không cần query thêm khi gọi getCourses()
         
         - Tại sao không còn N+1?
           + Trước: getCourses() trong loop → trigger query mới (LAZY loading)
           + Sau: getCourses() chỉ đọc từ memory (đã được fetch sẵn) → không có query mới
           + Kết quả: 1 query duy nhất thay vì N+1 queries
    
  - Lưu ý:
    + Luôn dùng DISTINCT khi JOIN FETCH để tránh duplicate results
    + Kiểm tra SQL logs (spring.jpa.show-sql=true) để phát hiện N+1
    + Test với dữ liệu thực tế để chọn giải pháp phù hợp
    + Có thể combine: Entity Graph + DTO Projection cho API endpoints


###( Guide Note 161)###
* Các loại Index trong MySQL:
  1. PRIMARY KEY (Clustered Index):
     - Định nghĩa: Index tự động tạo khi khai báo PRIMARY KEY, là clustered index (dữ liệu được sắp xếp theo PK)
     - Ví dụ:
       CREATE TABLE users (
           user_id INT PRIMARY KEY AUTO_INCREMENT,  -- Tự động tạo PRIMARY KEY index
           username VARCHAR(50),
           email VARCHAR(100)
       );
       -- Hoặc trong JPA:
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Integer userId;  -- Tự động tạo PRIMARY KEY index
     
     - Lợi ích:
       + Tốc độ truy vấn nhanh nhất: O(log n) để tìm kiếm
       + Dữ liệu được sắp xếp vật lý theo PK → range queries rất nhanh
       + Tự động UNIQUE → đảm bảo tính duy nhất
       + Foreign key references hiệu quả
       + Mỗi bảng chỉ có 1 PRIMARY KEY → tối ưu storage
     
     - Tác hại:
       + Chỉ có 1 PRIMARY KEY per table
       + Khi update PK → phải rebuild toàn bộ table (rất chậm)
       + PK nên là INT/BIGINT → nếu dùng VARCHAR/UUID sẽ chậm hơn
       + Insert vào giữa PK sequence → có thể gây page split (fragmentation)
     
     - Khi nào dùng: Luôn dùng cho mỗi table (best practice)
  
  2. UNIQUE INDEX:
     - Định nghĩa: Index đảm bảo giá trị duy nhất, cho phép NULL (nhưng chỉ 1 NULL)
     - Ví dụ:
       CREATE TABLE users (
           user_id INT PRIMARY KEY,
           username VARCHAR(50) UNIQUE,  -- Tự động tạo UNIQUE index
           email VARCHAR(100),
           UNIQUE KEY uk_email (email)  -- Tạo UNIQUE index thủ công
       );
       -- Hoặc trong JPA:
       @Column(name = "username", unique = true)  -- Tự động tạo UNIQUE index
       private String username;
     
     - Lợi ích:
       + Đảm bảo tính duy nhất dữ liệu
       + Tốc độ lookup nhanh: O(log n)
       + Tối ưu cho WHERE clause với = operator
       + Có thể có nhiều UNIQUE indexes per table
     
     - Tác hại:
       + Tốn thêm storage (phải lưu index structure)
       + Chậm hơn khi INSERT/UPDATE (phải check uniqueness)
       + Nếu có nhiều NULL → có thể gây vấn đề (MySQL chỉ cho phép 1 NULL trong UNIQUE)
     
     - Khi nào dùng: Khi cần đảm bảo tính duy nhất (username, email, phone, etc.)
  
  3. INDEX (Non-unique, Non-clustered):
     - Định nghĩa: Index thông thường, không đảm bảo tính duy nhất, tăng tốc độ truy vấn
     - Ví dụ:
       CREATE TABLE students (
           id INT PRIMARY KEY,
           first_name VARCHAR(50),
           last_name VARCHAR(50),
           age INT,
           INDEX idx_first_name (first_name),  -- Index cho first_name
           INDEX idx_age (age)  -- Index cho age
       );
       -- Hoặc trong JPA (phải dùng @Table):
       @Table(name = "students", indexes = {
           @Index(name = "idx_first_name", columnList = "first_name"),
           @Index(name = "idx_age", columnList = "age")
       })
     
     - Lợi ích:
       + Tăng tốc độ SELECT queries đáng kể: O(log n) thay vì O(n) full table scan
       + Tối ưu cho WHERE, ORDER BY, JOIN
       + Có thể tạo nhiều indexes per table
       + Giảm I/O operations
     
     - Tác hại:
       + Tốn storage: mỗi index cần thêm ~20-30% storage
       + Chậm INSERT/UPDATE/DELETE: phải update index structure
       + Index không được sử dụng nếu query không match (waste storage)
       + Quá nhiều indexes → chậm write operations
     
     - Khi nào dùng: 
       + Columns thường dùng trong WHERE clause (foreign keys)
       + Columns dùng trong JOIN
       + Columns dùng trong ORDER BY
       + Không nên tạo quá nhiều (rule of thumb: < 5-7 indexes per table)
  
  4. COMPOSITE INDEX (Multi-column Index):
     - Định nghĩa: Index trên nhiều columns, thứ tự columns rất quan trọng
     - Ví dụ:
       CREATE TABLE orders (
           id INT PRIMARY KEY,
           user_id INT,
           status VARCHAR(20),
           created_at DATETIME,
           INDEX idx_user_status (user_id, status),  -- Composite index
           INDEX idx_status_created (status, created_at)  -- Thứ tự khác
       );
       -- Hoặc trong JPA:
       @Table(name = "orders", indexes = {
           @Index(name = "idx_user_status", columnList = "user_id,status")
       })
     
     - Lợi ích:
       + Tối ưu queries với nhiều WHERE conditions
       + Có thể dùng cho "leftmost prefix": idx(a,b,c) dùng được cho (a), (a,b), (a,b,c)
       + Giảm số lượng indexes cần thiết
       + Tốt cho queries phức tạp
     
     - Tác hại:
       + Thứ tự columns rất quan trọng → phải thiết kế cẩn thận
       + Chỉ dùng được nếu query match leftmost prefix
       + Ví dụ: idx(user_id, status) KHÔNG dùng được cho query chỉ có WHERE status = ?
       + Tốn storage hơn single-column index
     
     - Khi nào dùng:
       + Queries thường filter theo nhiều columns cùng lúc
       + Cần tối ưu ORDER BY với WHERE
       + Rule: đặt column có selectivity cao (nhiều giá trị unique) trước
  
  5. FULLTEXT INDEX:
     - Định nghĩa: Index đặc biệt cho full-text search, chỉ dùng với MyISAM hoặc InnoDB (MySQL 5.6+)
     - Ví dụ:
       CREATE TABLE articles (
           id INT PRIMARY KEY,
           title VARCHAR(200),
           content TEXT,
           FULLTEXT INDEX ft_title_content (title, content)
       );
       -- Query:
       SELECT * FROM articles 
       WHERE MATCH(title, content) AGAINST('spring boot' IN NATURAL LANGUAGE MODE);
     
     - Lợi ích:
       + Tối ưu cho full-text search (tìm kiếm văn bản)
       + Hỗ trợ relevance ranking
       + Nhanh hơn nhiều so với LIKE '%keyword%'
       + Hỗ trợ stop words, stemming
     
     - Tác hại:
       + Chỉ dùng được với TEXT/VARCHAR columns
       + Tốn nhiều storage
       + Chỉ dùng được với MATCH...AGAINST syntax
       + Không dùng được cho exact match
       + Cần rebuild khi update (có thể chậm)
     
     - Khi nào dùng: Khi cần tìm kiếm văn bản (search engine, articles, comments, etc.)
  
  6. COVERING INDEX (Index-Only Scan):
     - Định nghĩa: Index chứa tất cả columns cần thiết cho query → không cần đọc table data
     - Ví dụ:
       CREATE TABLE students (
           id INT PRIMARY KEY,
           first_name VARCHAR(50),
           last_name VARCHAR(50),
           age INT,
           -- Covering index: chứa tất cả columns trong SELECT
           INDEX idx_covering (first_name, last_name, age)
       );
       -- Query được optimize:
       SELECT first_name, last_name, age FROM students WHERE first_name = 'John';
       -- MySQL chỉ đọc từ index, không cần đọc table → rất nhanh
      
     - Lợi ích:
       + Rất nhanh: không cần đọc table data (index-only scan)
       + Giảm I/O operations đáng kể
       + Tốt cho read-heavy workloads
     
     - Tác hại:
       + Index size lớn hơn (chứa nhiều columns)
       + Chậm INSERT/UPDATE (phải update nhiều columns trong index)
       + Chỉ hiệu quả nếu query chỉ select columns trong index
     
     - Khi nào dùng: 
       + Read-heavy queries
       + Queries chỉ select một số columns cụ thể
       + Khi index columns cover toàn bộ SELECT clause

    * MySQL tự động sử dụng index - KHÔNG cần khai báo trong query:
         - MySQL Query Optimizer tự động phân tích query và chọn index phù hợp nhất
         - Bạn KHÔNG cần khai báo index trong query (khác với một số DB khác có thể hint index)
         - MySQL tự động quyết định dựa trên:
           + Columns trong WHERE clause
           + Columns trong SELECT clause
           + Statistics của table (số lượng rows, distribution, etc.)
           + Cost estimation (ước tính chi phí)
         
         - Cách MySQL quyết định sử dụng index:
           1. MySQL phân tích query: SELECT first_name, last_name, age WHERE first_name = 'John'
           2. MySQL kiểm tra các indexes có sẵn:
              - idx_covering (first_name, last_name, age) → Covering index
              - idx_first_name (first_name) → Partial index
              - PRIMARY KEY (id)
           3. MySQL ước tính cost cho mỗi index:
              - idx_covering: Cost thấp (index-only scan, không cần đọc table)
              - idx_first_name: Cost cao hơn (cần đọc table để lấy last_name, age)
              - PRIMARY KEY: Cost rất cao (full table scan)
           4. MySQL chọn index có cost thấp nhất: idx_covering
           5. MySQL tự động sử dụng index đó → Bạn không cần làm gì
         
         - Ví dụ tất cả các loại index đều tự động:
           -- PRIMARY KEY - Tự động sử dụng
           SELECT * FROM students WHERE id = 1;  -- MySQL tự dùng PRIMARY KEY
           
           -- UNIQUE INDEX - Tự động sử dụng
           SELECT * FROM users WHERE username = 'john';  -- MySQL tự dùng UNIQUE index trên username
           
           -- INDEX - Tự động sử dụng
           SELECT * FROM students WHERE first_name = 'John';  -- MySQL tự dùng index trên first_name
           
           -- COMPOSITE INDEX - Tự động sử dụng
           SELECT * FROM orders WHERE user_id = 1 AND status = 'PENDING';  -- MySQL tự dùng composite index
           
           -- COVERING INDEX - Tự động sử dụng
           SELECT first_name, last_name, age FROM students WHERE first_name = 'John';
           -- MySQL tự dùng covering index (nếu có)
         
         - Khi nào MySQL KHÔNG sử dụng index?
           + Query không match với index (không có WHERE clause phù hợp)
           + Full table scan nhanh hơn (table quá nhỏ)
           + Index có selectivity thấp (quá nhiều duplicate values)
           + Query có function trên column: WHERE UPPER(first_name) = 'JOHN' (không dùng index)
           + Query có LIKE với wildcard đầu: WHERE first_name LIKE '%John' (không dùng index)
           + Query có toán tử NOT: WHERE first_name != 'John' (có thể không dùng index)
         
         - Cách kiểm tra MySQL có dùng index hay không:
           EXPLAIN SELECT first_name, last_name, age FROM students WHERE first_name = 'John';
           
           Kết quả:
           +----+-------------+----------+------+---------------+----------------+---------+-------+------+-------------+
           | id | select_type | table    | type | possible_keys | key            | key_len | ref   | rows | Extra       |
           +----+-------------+----------+------+---------------+----------------+---------+-------+------+-------------+
           |  1 | SIMPLE      | students | ref  | idx_covering  | idx_covering   | 203     | const |    2 | Using index|
           +----+-------------+----------+------+---------------+----------------+---------+-------+------+-------------+
           
           Giải thích:
           - key: idx_covering → MySQL đã chọn index này
           - Extra: "Using index" → Index-only scan (covering index)
           - Nếu Extra: "Using where; Using index" → Dùng index nhưng cần filter thêm
           - Nếu key: NULL → MySQL KHÔNG dùng index (full table scan)
  
  - Best Practices:
    + Tạo index cho foreign keys (tự động trong một số DB, nhưng nên check)
    + Index columns thường dùng trong WHERE, JOIN, ORDER BY
    + Sử dụng EXPLAIN để kiểm tra index usage
    + Monitor index usage: DROP indexes không được sử dụng
    + Cân bằng giữa read performance và write performance
    + Composite index: đặt column có selectivity cao trước
    + Tránh index trên columns có nhiều NULL values
    + Index trên columns có data type nhỏ (INT tốt hơn VARCHAR)
  
  - Cách kiểm tra index usage trong MySQL:
    SELECT * FROM sys.schema_unused_indexes;  -- MySQL 5.7+
    SHOW INDEX FROM table_name;
    EXPLAIN SELECT ...;  -- Xem execution plan


###( Guide Note 163)###
* Vấn đề Race Condition / Lost Update:
  - Khi 2 requests cùng lúc update cùng 1 record:
    Request 1: Đọc balance = 100, Update balance = 100 + 50 = 150
    Request 2: Đọc balance = 100, Update balance = 100 - 30 = 70
    Kết quả: balance = 70 (mất update của Request 1) ❌
  
  - MySQL - Giải pháp:
  → KHUYẾN NGHỊ CHUNG CHO MYSQL:
         - Ưu tiên: Optimistic Locking (@Version) + @Transactional

         * Optimistic Locking (@Version) - KHUYẾN NGHỊ CHO HẦU HẾT TRƯỜNG HỢP ⭐⭐⭐⭐⭐
         - Phổ biến nhất: Được dùng trong hầu hết các ứng dụng Spring Boot
         - Tối ưu: Không blocking, hiệu suất cao, phù hợp với read-heavy workloads
         - Dễ implement: Chỉ cần thêm @Version field
         - Spring Data JPA tự động xử lý version checking
         - Khi nào dùng: 90% các trường hợp (ít conflict, read-heavy)
         - Ví dụ: User management, product inventory (ít conflict), order processing (read-heavy)

         * @Transactional (Isolation Level) - BẮT BUỘC ⭐⭐⭐⭐⭐
         - Luôn luôn dùng: Cho mọi operations phức tạp
         - Default: REPEATABLE_READ (InnoDB) - đã đủ tốt cho hầu hết trường hợp
         - Không cần thay đổi isolation level trừ khi có vấn đề cụ thể
         - Kết hợp: Thường dùng với Optimistic hoặc Pessimistic locking

    * Cách thực hiện:
    Bước 1: Thêm @Version field vào Entity
       @Entity
       @Table(name = "users")
       public class User {
           @Id
           @GeneratedValue(strategy = GenerationType.IDENTITY)
           private Long id;
           
           @Version  // ← Thêm field này để enable optimistic locking
           private Long version;  // Spring Data JPA tự động quản lý
           
           private BigDecimal balance;
           // ... other fields
       }
    
    Bước 2: Sử dụng @Transactional với Optimistic Locking
       @Service
       public class UserService {
           @Autowired
           private UserRepository userRepo;
           
           // Với retry mechanism (khuyến nghị)
           @Retryable(value = {OptimisticLockingFailureException.class}, maxAttempts = 3)
           @Transactional(rollbackFor = Exception.class)
           public void updateBalanceWithRetry(Long userId, BigDecimal amount) {
               User user = userRepo.findById(userId)
                   .orElseThrow(() -> new NotFoundException("User not found"));
               
               user.setBalance(user.getBalance().add(amount));
               userRepo.save(user);
           }
       }
    
    * Cơ chế hoạt động chi tiết:
      - Đúng! Khi thêm @Version vào entity:
        1. Mỗi entity có version nhất định (bắt đầu từ 0 hoặc 1)
        2. Khi SELECT: Entity được load với version hiện tại
           VD: User(id=1, balance=100, version=5)
        3. Khi UPDATE: Spring Data JPA tự động:
           - Tăng version: version = version + 1
           - Check version trong WHERE clause: WHERE id = ? AND version = ?
           - SQL: UPDATE users SET balance = ?, version = version + 1 
                  WHERE id = ? AND version = ?
        4. Nếu version khác → 0 rows affected → OptimisticLockingFailureException
        5. Exception → @Transactional rollback → Tất cả changes trong transaction bị rollback
        6. @Retryable tự động retry với version mới → Nếu thành công thì commit
      
      - Ví dụ cụ thể với 2 requests cùng lúc:
        Database: User(id=1, balance=100, version=5)
        
        Request 1 (Thread 1):
          - BEGIN TRANSACTION
          - SELECT: User(id=1, balance=100, version=5)  ← Load với version=5
          - Calculate: balance = 100 + 50 = 150
          - UPDATE: UPDATE users SET balance=150, version=6 WHERE id=1 AND version=5
          - COMMIT → Success, version=6
        
        Request 2 (Thread 2) - xảy ra cùng lúc:
          - BEGIN TRANSACTION
          - SELECT: User(id=1, balance=100, version=5)  ← Vẫn load version=5 (chưa commit Request 1)
          - Calculate: balance = 100 - 30 = 70
          - UPDATE: UPDATE users SET balance=70, version=6 WHERE id=1 AND version=5
          - Database check: version hiện tại = 6 (Request 1 đã update) ≠ 5
          - 0 rows affected → OptimisticLockingFailureException
          - @Transactional rollback → Changes bị rollback
          - @Retryable retry:
            - SELECT lại: User(id=1, balance=150, version=6)  ← Load version mới
            - Calculate: balance = 150 - 30 = 120
            - UPDATE: UPDATE users SET balance=120, version=7 WHERE id=1 AND version=6
            - COMMIT → Success, version=7
          - Kết quả: balance=120 (đúng) ✅
      
      - Nếu không có @Version:
        Request 1: UPDATE balance=150
        Request 2: UPDATE balance=70
        Kết quả: balance=70 (mất update của Request 1) ❌
      
      - Tóm lại:
        + @Version: Mỗi entity có version → mỗi thao tác có version nhất định
        + Khi xong thao tác: Version được tăng (version = version + 1)
        + Nếu khác version: Throw OptimisticLockingFailureException
        + Exception → Rollback (tất cả changes trong transaction)
        + @Retryable: Tự động retry với version mới → Nếu thành công thì commit
        + Nếu retry fail (sau maxAttempts) → Throw exception cuối cùng
    
    - Isolation levels (có thể config nếu cần):
       @Transactional(isolation = Isolation.REPEATABLE_READ)  // Default InnoDB
       // Hoặc:
       @Transactional(isolation = Isolation.READ_COMMITTED)   // Default MySQL
       // Không nên thay đổi trừ khi có vấn đề cụ thể
    
    - Xử lý OptimisticLockingFailureException:
      + Retry mechanism: @Retryable (Spring Retry) hoặc manual retry
      + Log conflict để monitor
      + Return error message cho user nếu retry fail
    
    - Ưu điểm của kết hợp này:
      + @Transactional: Đảm bảo ACID, rollback nếu có lỗi
      + @Version: Đảm bảo không có lost update, không blocking
      + Hiệu suất cao: Không block như pessimistic locking
      + Tự động: Spring Data JPA xử lý version checking
    
    - Lưu ý:
      + Luôn dùng @Transactional với Optimistic Locking
      + Nên có retry mechanism cho OptimisticLockingFailureException
      + Monitor số lượng conflicts để đánh giá có cần chuyển sang Pessimistic Locking không
  

  - Redis - Giải pháp:
  → KHUYẾN NGHỊ CHUNG CHO REDIS:
    - Ưu tiên: INCR/DECR (nếu chỉ cần increment/decrement)

    INCR/DECR - ĐƠN GIẢN NHẤT, TỐI ƯU NHẤT ⭐⭐⭐⭐⭐
         - Phổ biến nhất: Dùng cho counters, simple increments
         - Tối ưu: Atomic, không cần lock, hiệu suất cao nhất
         - Dễ implement: 1 dòng code
         - Khi nào dùng: Khi chỉ cần increment/decrement số
         - Ví dụ: View counters, like counts, vote counts

    * Redis INCR/DECR (Atomic Operations):
       public void incrementBalance(String userId, BigDecimal amount) {
           String key = "user:balance:" + userId;
           redisTemplate.opsForValue().increment(key, amount.doubleValue());
       }
       - Cơ chế: INCR/DECR là atomic operations
       - Ưu điểm: Đơn giản, atomic, không cần lock
       - Nhược điểm: Chỉ dùng được cho số (integer/float)
       - Khi nào dùng: Khi chỉ cần increment/decrement số
  
  
  - Best Practices:
    + MySQL: 
      - Ưu tiên Optimistic Locking (@Version) cho hầu hết trường hợp
      - Dùng Pessimistic Locking chỉ khi thực sự cần (nhiều conflicts)
      - Luôn dùng @Transactional với isolation level mặc định (REPEATABLE_READ)
      - Retry mechanism cho OptimisticLockingFailureException
    + Redis:
      - Ưu tiên atomic operations (INCR/DECR, Lua scripts) khi có thể
      - Dùng distributed locks (SETNX) cho critical operations
      - Tránh WATCH + MULTI/EXEC nếu có thể dùng Lua scripts
    + Cả 2:
      - Monitor và log locking conflicts để optimize
      - Test với concurrent load để đảm bảo solution hoạt động
      - Có retry mechanism cho optimistic locking conflicts


###( Guide Note 166)###
* DESIGN PATTERNS ĐANG SỬ DỤNG:

  1. Builder Pattern ⭐⭐⭐⭐⭐
     - Mục đích: Xây dựng object phức tạp một cách linh hoạt
     - Cách dùng: Lombok @Builder annotation
     - Ví dụ trong code:
       @Builder
       public class UserDto { ... }
       UserDto user = UserDto.builder()
           .username("john")
           .firstName("John")
           .build();
     - Lợi ích: Code sạch, dễ đọc, không cần constructor với nhiều tham số
     - File: UserDto.java, Register.java, LogContext.java

  2. Repository Pattern ⭐⭐⭐⭐⭐
     - Mục đích: Tách biệt logic truy cập database khỏi business logic
     - Cách dùng: Spring Data JPA Repository
     - Ví dụ trong code:
       @Repository
       public interface UserRepo extends JpaRepository<UserEntity, Integer> {
           Optional<UserEntity> findByUsername(String username);
       }
     - Lợi ích: Tự động generate query methods, dễ test, dễ maintain
     - File: UserRepo.java, StudentRepo.java, TeacherRepo.java

  3. Service Layer Pattern ⭐⭐⭐⭐⭐
     - Mục đích: Tách biệt business logic khỏi controller và repository
     - Cách dùng: Interface + Implementation
     - Ví dụ trong code:
       public interface StudentService { ... }
       @Service
       public class StudentServiceImp implements StudentService { ... }
     - Lợi ích: Dễ test, dễ thay đổi implementation, tuân thủ SOLID
     - File: StudentService.java, StudentServiceImp.java

  4. DTO (Data Transfer Object) Pattern ⭐⭐⭐⭐⭐
     - Mục đích: Tách biệt entity (database) với data truyền qua API
     - Cách dùng: Tạo các class DTO riêng
     - Ví dụ trong code:
       UserDto, StudentModel, TeacherModel, Register, Login
     - Lợi ích: Bảo mật (che dấu password), linh hoạt (khác với entity structure)
     - File: UserDto.java, StudentModel.java, Register.java

  5. AOP / Proxy Pattern ⭐⭐⭐⭐⭐
     - Mục đích: Thêm cross-cutting concerns (logging, security) mà không thay đổi code
     - Cách dùng: @Aspect, @Around, @Before, @After
     - Ví dụ trong code:
       @Aspect
       @Around("@annotation(RequiresAuth)")
       public Object validateAuth(ProceedingJoinPoint joinPoint) { ... }
     - Lợi ích: Tách biệt concerns, tái sử dụng code, không xâm nhập business logic
     - File: RequiresAuthAspect.java

  6. Factory Pattern ⭐⭐⭐⭐
     - Mục đích: Tạo objects mà không cần biết class cụ thể
     - Cách dùng: @Bean, @Configuration trong Spring
     - Ví dụ trong code:
       @Configuration
       public class ApplicationConfig {
           @Bean
           public PasswordEncoder passwordEncoder() {
               return new BCryptPasswordEncoder();
           }
       }
     - Lợi ích: Centralized object creation, dễ test, dễ thay đổi implementation
     - File: ApplicationConfig.java, KafkaConfig.java, RedisConfig.java

  7. Template Method Pattern ⭐⭐⭐⭐
     - Mục đích: Định nghĩa skeleton của algorithm, để subclass implement các bước cụ thể
     - Cách dùng: Abstract class với abstract method
     - Ví dụ trong code:
       public abstract class KafkaConsumerService<T> {
           public void handleEvent(...) {
               processEvent(event);  // Template method
               acknowledgment.acknowledge();
           }
           protected abstract void processEvent(T event);  // Subclass implement
       }
     - Lợi ích: Tái sử dụng code, dễ extend, consistent structure
     - File: KafkaConsumerService.java

  8. Strategy Pattern ⭐⭐⭐
     - Mục đích: Chọn algorithm lúc runtime
     - Cách dùng: Switch case, enum, hoặc interface với nhiều implementation
     - Ví dụ trong code:
       switch (event.getAction()) {
           case "CREATED": handleStudentCreated(event); break;
           case "UPDATED": handleStudentUpdated(event); break;
       }
     - Lợi ích: Dễ thêm strategy mới, tách biệt logic
     - File: StudentEventConsumerService.java, NotificationService.java

  9. Chain of Responsibility Pattern ⭐⭐⭐⭐
     - Mục đích: Xử lý request qua một chuỗi handlers
     - Cách dùng: Spring Security Filter Chain
     - Ví dụ trong code:
       SecurityFilterChain -> JwtAuthFilter -> Controller
     - Lợi ích: Tách biệt concerns, dễ thêm/bớt filter
     - File: SecurityConfig.java, JwtAuthFilter.java

  10. Singleton Pattern ⭐⭐⭐⭐⭐
      - Mục đích: Đảm bảo chỉ có 1 instance của class
      - Cách dùng: Spring @Component, @Service, @Repository (mặc định singleton)
      - Ví dụ trong code:
        @Service
        public class StudentServiceImp { ... }  // Chỉ có 1 instance
      - Lợi ích: Tiết kiệm memory, shared state
      - File: Tất cả @Service, @Component classes

  11. Dependency Injection Pattern ⭐⭐⭐⭐⭐
      - Mục đích: Giảm coupling giữa các components
      - Cách dùng: @Autowired, constructor injection
      - Ví dụ trong code:
        @Service
        public class StudentServiceImp {
            @Autowired
            private StudentRepo studentRepo;
        }
      - Lợi ích: Loose coupling, dễ test, dễ maintain
      - File: Tất cả service classes

  12. Exception Handler Pattern ⭐⭐⭐⭐
      - Mục đích: Centralized exception handling
      - Cách dùng: @ControllerAdvice, @ExceptionHandler
      - Ví dụ trong code:
        @RestControllerAdvice
        public class CustomExceptionHandler {
            @ExceptionHandler(NotFoundExceptionHandle.class)
            ResponseEntity<Response<?>> notFoundExceptionHandler(...) { ... }
        }
      - Lợi ích: Consistent error responses, dễ maintain
      - File: CustomExceptionHandler.java

  13. Adapter Pattern ⭐⭐⭐
      - Mục đích: Chuyển đổi interface của một class sang interface khác
      - Cách dùng: RestTemplate để gọi REST API
      - Ví dụ trong code:
        SecurityService sử dụng RestTemplate để gọi Security module API
      - Lợi ích: Tích hợp với external systems
      - File: SecurityService.java, RestTemplateConfig.java

  14. Observer Pattern ⭐⭐⭐⭐
      - Mục đích: Notify multiple objects khi có event
      - Cách dùng: Kafka @KafkaListener
      - Ví dụ trong code:
        @KafkaListener(topics = "student-events")
        public void handleStudentEvent(...) { ... }
      - Lợi ích: Decoupled communication, event-driven architecture
      - File: StudentEventConsumerService.java, NotificationConsumerService.java

  15. Facade Pattern ⭐⭐⭐
      - Mục đích: Cung cấp interface đơn giản cho complex subsystem
      - Cách dùng: SecurityService facade cho Security module
      - Ví dụ trong code:
        SecurityService.validateAndAuthorize() - ẩn complexity của RestTemplate calls
      - Lợi ích: Simplified interface, hide complexity
      - File: SecurityService.java

  - DESIGN PATTERNS CÓ THỂ THÊM VÀO:

    1. Circuit Breaker Pattern ⭐⭐⭐⭐⭐
      - Mục đích: Prevent cascade failures khi service down
      - Ứng dụng:
        + Khi SecurityService gọi Security module API
        + External API calls
        + Database connections
      - Ví dụ:
        @CircuitBreaker(name = "security-service", fallbackMethod = "fallback")
        public UserDto validateToken(String token) { ... }
      - Lợi ích: Prevent cascade failures, graceful degradation
      - Tool: Spring Cloud Circuit Breaker, Resilience4j
      
      * GIẢI THÍCH CHI TIẾT:
      
      - Vấn đề cần giải quyết:
        + Khi SecurityService gọi Security module API, nếu Security module DOWN:
          → RestTemplate.exchange() sẽ throw exception (Connection refused, Timeout, etc.)
          → Mỗi request phải chờ timeout (có thể 30s, 60s) → User experience rất tệ
          → Tất cả requests bị block → Cascade failure → Toàn bộ system chết
        + Ví dụ thực tế:
          Request 1: Gọi Security API → Timeout 30s → Fail
          Request 2: Gọi Security API → Timeout 30s → Fail
          Request 3: Gọi Security API → Timeout 30s → Fail
          ... (1000 requests cùng lúc)
          → Tất cả requests bị block → System không thể xử lý request nào khác
      
      - Cơ chế hoạt động (3 trạng thái):
        
        1. CLOSED (Trạng thái bình thường):
            + Requests được gửi bình thường
            + Circuit Breaker theo dõi số lượng failures
            + Nếu failure rate < threshold → Giữ nguyên CLOSED
            + Ví dụ: Failure rate < 50% → CLOSED
        
        2. OPEN (Circuit mở - Bỏ qua service):
            + Khi failure rate >= threshold (VD: 50% failures trong 10 requests)
            + Circuit Breaker tự động chuyển sang OPEN
            + Tất cả requests bị reject NGAY LẬP TỨC (không gọi service)
            + Gọi fallback method ngay lập tức
            + Sau một thời gian (waitDurationInOpenState), chuyển sang HALF_OPEN
            + Lợi ích: Tránh lãng phí resources, trả về response nhanh
        
        3. HALF_OPEN (Thử nghiệm):
            + Sau waitDurationInOpenState (VD: 60s), chuyển sang HALF_OPEN
            + Cho phép một số requests (permittedNumberOfCallsInHalfOpenState) đi qua
            + Nếu thành công → Chuyển về CLOSED
            + Nếu fail → Chuyển về OPEN (tiếp tục wait)
            + Mục đích: Kiểm tra xem service đã recover chưa
      
      - Ví dụ cụ thể với SecurityService:

      ** CACHING + THROW EXCEPTION (KHUYẾN NGHỊ cho Authentication) **
        
        BƯỚC 1: Thêm dependency (pom.xml):
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-spring-boot3</artifactId>
            <version>2.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        
        BƯỚC 2: Configuration - Tạo trong model_shared (Config chung cho toàn bộ project):
        
        Vì model_shared là nơi tập trung các config chung, nên tạo Circuit Breaker Config ở đây.
        Tất cả các module sử dụng model_shared sẽ tự động có Circuit Breaker config này.
        
        Đã tạo file: model_shared/src/main/java/com/model_shared/config/Resilience4jCircuitBreakerConfig.java
        
        @Configuration
        public class Resilience4jCircuitBreakerConfig {
            @Bean
            @ConditionalOnMissingBean
            public CircuitBreakerConfigCustomizer securityServiceCircuitBreakerCustomizer() {
                return CircuitBreakerConfigCustomizer.of("security-service", builder -> {
                    builder
                        .slidingWindowSize(10)  # Số lượng requests để tính failure rate
                        .minimumNumberOfCalls(5)  # Phải có ít nhất 5 calls mới tính failure rate
                        .permittedNumberOfCallsInHalfOpenState(3)  # Cho phép 3 calls trong HALF_OPEN
                        .automaticTransitionFromOpenToHalfOpenEnabled(true)
                        .waitDurationInOpenState(Duration.ofSeconds(60))  # Đợi 60s trước khi chuyển sang HALF_OPEN
                        .failureRateThreshold(50f)  # 50% failures → OPEN
                        .slowCallRateThreshold(100f)  # 100% slow calls → OPEN
                        .slowCallDurationThreshold(Duration.ofSeconds(2))  # Call > 2s được tính là slow
                        .eventConsumerBufferSize(10)
                        .recordExceptions(
                            java.net.ConnectException.class,
                            java.net.SocketTimeoutException.class,
                            org.springframework.web.client.ResourceAccessException.class
                        )
                        .ignoreExceptions(
                            com.handle_exceptions.UnauthorizedExceptionHandle.class,
                            com.handle_exceptions.ForbiddenExceptionHandle.class
                        );
                });
            }
        }
        
        Lưu ý:
        + Config này được đặt trong model_shared → Tất cả module sử dụng model_shared sẽ có config này
        + Module sử dụng có thể override bằng cách thêm vào application.properties nếu cần:
          resilience4j.circuitbreaker.instances.security-service.failureRateThreshold=30
        + Có thể thêm các Circuit Breaker config khác cho các service khác (payment-service, etc.)
        + Không cần config gì thêm trong module sử dụng (qlsv, qlgv) - Config tự động được load
        
        BƯỚC 3: Implement trong SecurityService:
        
        ⚠️ QUAN TRỌNG 1: Fallback method PHẢI có cùng return type với method chính!
        - Không thể để void nếu method chính không phải void
        - Fallback strategy: Throw exception (không return giá trị)
        
        ⚠️ QUAN TRỌNG 2: Try-Catch trong method chính và Circuit Breaker
        - Circuit Breaker intercept ở AOP level (SAU KHI method throw exception)
        - Try-catch trong method chính VẪN thực thi bình thường
        - Catch block vẫn throw exception → Circuit Breaker intercept và chặn lại
        - Exception từ method chính KHÔNG được propagate (Circuit Breaker catch và suppress)
        - Circuit Breaker gọi fallback method
        - Fallback throw exception → Exception này propagate lên caller
        - Vậy chỉ có 1 exception được throw (từ fallback), KHÔNG phải 2 lần!
        
        Flow khi có exception (CHI TIẾT):
        1. Method chính thực thi try-catch (VẪN chạy bình thường)
        2. RestTemplate throw exception (Connection refused, Timeout, etc.)
        3. Catch block catch exception và throw ServiceUnavailableExceptionHandle
            ✅ Catch block VẪN thực thi: log error, throw exception
        4. Circuit Breaker intercept exception (ở AOP level, SAU khi method throw)
            ✅ Circuit Breaker chặn exception từ method chính (suppress, không propagate)
        5. Circuit Breaker gọi fallback method
        6. Fallback method throw exception (exception mới)
        7. Exception từ fallback propagate lên caller
        
        → Try-catch trong method chính VẪN thực thi và throw exception
        → Exception được throw bị Circuit Breaker chặn lại (intercept và suppress)
        → Circuit Breaker gọi fallback → Fallback throw exception mới
        → Chỉ có 1 exception được throw (từ fallback), không phải 2 lần!
        
        Tóm tắt:
        - Catch block vẫn throw exception → Bị Circuit Breaker chặn lại
        - Circuit Breaker gọi fallback → Fallback throw exception mới
        - Exception từ fallback propagate lên caller
        
        ⚠️ QUAN TRỌNG 3: Nên bỏ try-catch trong method chính khi có Circuit Breaker?
        - KHÔNG! Try-catch vẫn cần để xử lý business logic (404, validation, etc.)
        - Circuit Breaker chỉ catch exception và gọi fallback
        - Try-catch giúp xử lý các trường hợp đặc biệt (404, 403, etc.)
        - KHUYẾN NGHỊ: Giữ try-catch cho business logic, để Circuit Breaker handle technical failures
        
        @Service
        public class SecurityService {
            @Autowired
            private RestTemplate restTemplate;
            
            @CircuitBreaker(name = "security-service", fallbackMethod = "validateTokenFallback")
            public UserDto validateTokenAndGetUser(String token) {
                // Gọi Security module API
                ResponseEntity<Response<UserDto>> response = restTemplate.exchange(
                    securityBaseUrl + "/auth/validate",
                    HttpMethod.GET,
                    new HttpEntity<>(headers),
                    new ParameterizedTypeReference<>() {}
                );
                
                return response.getBody().getData();
            }
            
            // Fallback method - Gọi khi circuit OPEN hoặc service down
            // 
            // LƯU Ý QUAN TRỌNG về Parameters:
            // Resilience4j TỰ ĐỘNG truyền parameters từ method chính vào fallback method:
            // 1. Tất cả parameters từ method chính (theo thứ tự) → token
            // 2. Exception/Throwable ở cuối (OPTIONAL - không bắt buộc) → e
            //
            // Exception parameter là OPTIONAL - Có thể có hoặc không:
            //
            // CÁCH 1: Có Exception parameter (KHUYẾN NGHỊ) ⭐⭐⭐⭐⭐
            // Method chính: validateTokenAndGetUser(String token)
            // Fallback: validateTokenFallback(String token, Exception e)
            // → Có thể log exception, xử lý theo loại exception, etc.
            //
            // CÁCH 2: Không có Exception parameter ⭐⭐⭐
            // Method chính: validateTokenAndGetUser(String token)
            // Fallback: validateTokenFallback(String token)
            // → Vẫn hoạt động, nhưng không biết exception là gì
            //
            // Nếu method chính không có parameters:
            // Method chính: getUser()
            // Fallback: getUserFallback(Throwable e)  // Chỉ có Exception parameter
            // Hoặc: getUserFallback()  // Không có Exception parameter
            //
            
            public UserDto validateTokenFallback(String token, Exception e) {
                LogContext logContext = getLogContext("validateTokenFallback");
                loggingService.logError("Security service unavailable, using fallback", e, logContext);
                
                // STRATEGY: Caching + Throw Exception (KHUYẾN NGHỊ cho Authentication)
                // 
                // 1. Thử lấy từ cache trước (nếu có)
                // 2. Nếu không có cache → Throw exception (không thể authenticate)
                //
                // Lý do:
                // - Authentication là critical operation → Không thể return default user (security risk)
                // - Cache giúp giảm load khi service tạm thời down
                // - Nếu không có cache → Phải throw exception để user biết cần retry
                
                // Thử lấy từ cache (Redis)
                String cacheKey = "user:token:" + token;
                UserDto cachedUser = redisTemplate.opsForValue().get(cacheKey);
                
                if (cachedUser != null) {
                    loggingService.logWarn("Using cached user data due to service unavailability: " 
                        + cachedUser.getUsername(), logContext);
                    return cachedUser;
                }
                
                // Không có cache → Throw exception
                throw new ServiceUnavailableExceptionHandle(
                    "Security service is currently unavailable",
                    "Please try again later"
                );
            }
            
            // Lưu ý: Cần cache user khi validate thành công (trong method chính):
            // @CircuitBreaker(name = "security-service", fallbackMethod = "validateTokenFallback")
            // public UserDto validateTokenAndGetUser(String token) {
            //     // ... validate token ...
            //     UserDto user = response.getBody().getData();
            //     
            //     // Cache user với TTL ngắn (5-10 phút) để giảm load nhưng vẫn đảm bảo security
            //     String cacheKey = "user:token:" + token;
            //     redisTemplate.opsForValue().set(cacheKey, user, Duration.ofMinutes(5));
            //     
            //     return user;
            // }
        }
        
        BƯỚC 4: Flow hoạt động:
        
        Scenario 1: Service hoạt động bình thường (CLOSED):
          Request 1: validateToken() → Success → Circuit: CLOSED
          Request 2: validateToken() → Success → Circuit: CLOSED
          Request 3: validateToken() → Success → Circuit: CLOSED
          → Tất cả requests đi qua bình thường
        
        Scenario 2: Service bắt đầu fail (CLOSED → OPEN):
          Request 1: validateToken() → Success → Circuit: CLOSED (1/1 success)
          Request 2: validateToken() → Fail → Circuit: CLOSED (1/2 success, 50% failure)
          Request 3: validateToken() → Fail → Circuit: CLOSED (1/3 success, 66% failure)
          Request 4: validateToken() → Fail → Circuit: CLOSED (1/4 success, 75% failure)
          Request 5: validateToken() → Fail → Circuit: CLOSED (1/5 success, 80% failure)
          → Failure rate = 80% > 50% threshold
          → Circuit chuyển sang OPEN
        
        Scenario 3: Circuit OPEN (Bỏ qua service):
          Request 6: validateToken() → Circuit OPEN → Reject ngay → Gọi fallback()
          Request 7: validateToken() → Circuit OPEN → Reject ngay → Gọi fallback()
          Request 8: validateToken() → Circuit OPEN → Reject ngay → Gọi fallback()
          → Tất cả requests bị reject ngay, không gọi service
          → Response time: < 1ms (rất nhanh)
          → Đợi 60s (waitDurationInOpenState)
        
        Scenario 4: Circuit HALF_OPEN (Thử nghiệm):
          Sau 60s → Circuit chuyển sang HALF_OPEN
          Request 9: validateToken() → Cho phép đi qua → Nếu Success → Circuit: CLOSED
          Request 10: validateToken() → Cho phép đi qua → Nếu Fail → Circuit: OPEN (tiếp tục wait)
        
      - So sánh CÓ/KHÔNG Circuit Breaker:
        
        KHÔNG có Circuit Breaker:
          Request 1: validateToken() → Timeout 30s → Fail
          Request 2: validateToken() → Timeout 30s → Fail
          Request 3: validateToken() → Timeout 30s → Fail
          ... (1000 requests)
          → Tất cả requests phải chờ 30s → Tổng thời gian: 30,000s
          → System bị block, không thể xử lý request khác
          → User experience: Rất tệ
        
        CÓ Circuit Breaker:
          Request 1-5: validateToken() → Fail → Circuit: OPEN
          Request 6+: validateToken() → Circuit OPEN → Reject ngay → Fallback (< 1ms)
          → Response time: < 1ms (rất nhanh)
          → System không bị block
          → User experience: Tốt hơn (nhận được error message nhanh)
          → Sau 60s, tự động thử lại (HALF_OPEN) để check service đã recover chưa
      
      - Best Practices:
        + Luôn có fallback method → Tránh throw exception không cần thiết
        + Fallback strategy phụ thuộc vào loại operation (xem chi tiết bên dưới)
        + Monitor circuit breaker state → Log khi chuyển trạng thái
        + Tune configuration dựa trên business requirements:
          - High availability → Lower failureRateThreshold (VD: 30%)
          - Performance critical → Lower slowCallDurationThreshold (VD: 1s)
        + Combine với Retry Pattern → Retry trước, Circuit Breaker sau
        + Metrics & Monitoring → Track circuit breaker state changes

    2. Decorator Pattern ⭐⭐⭐
      - Mục đích: Thêm behavior động vào object
      - Ứng dụng:
        + Caching decorator cho service methods
        + Retry decorator cho API calls
        + Logging decorator
      - Ví dụ:
        @Cacheable
        @Retryable
        public StudentModel getStudent() { ... }
      - Lợi ích: Flexible behavior addition, không cần modify existing code

    3. Memento Pattern ⭐⭐⭐
      - Mục đích: Save và restore state của object
      - Ứng dụng:
        + Version history cho entities
        + Undo/redo functionality
        + Backup/restore data
      - Ví dụ:
        class StudentMemento {
            private StudentEntity state;
            // Save state
        }
      - Lợi ích: Track changes, restore previous states

    4. State Pattern ⭐⭐⭐
      - Mục đích: Thay đổi behavior dựa trên state
      - Ứng dụng:
        + User status (PENDING, ENABLED, DISABLED)
        + Order status workflow
        + Entity lifecycle management
      - Ví dụ:
        interface UserState {
            void handle(UserEntity user);
        }
        class PendingState implements UserState { ... }
      - Lợi ích: Clean state transitions, dễ test

    5. Visitor Pattern ⭐⭐
      - Mục đích: Thêm operations vào object structure mà không modify objects
      - Ứng dụng:
        + Export data (JSON, XML, CSV)
        + Validation across different entities
        + Report generation
      - Ví dụ:
        interface EntityVisitor {
            void visit(StudentEntity student);
            void visit(TeacherEntity teacher);
        }
      - Lợi ích: Open/Closed principle, dễ thêm operations mới

    6. Specification Pattern ⭐⭐⭐⭐
      - Mục đích: Encapsulate business rules, reusable predicates
      - Ứng dụng:
        + Complex filtering logic
        + Query building
        + Business rule validation
      - Ví dụ:
        interface Specification<T> {
            boolean isSatisfiedBy(T entity);
        }
        class GraduateStudentSpec implements Specification<Student> { ... }
      - Lợi ích: Reusable business rules, dễ test, dễ combine

    7. Unit of Work Pattern ⭐⭐⭐⭐⭐
      - Mục đích: Track changes và commit tất cả cùng lúc
      - Ứng dụng:
        + Transaction management (đã có @Transactional nhưng có thể improve)
        + Batch operations
        + Change tracking
      - Ví dụ:
        @Transactional
        public void updateStudentAndUser() {
            // All changes tracked và committed together
        }
      - Lợi ích: Consistency, transaction management

    8. CQRS (Command Query Responsibility Segregation) ⭐⭐⭐⭐
      - Mục đích: Tách biệt read và write operations
      - Ứng dụng:
        + Separate read models (DTOs) và write models (Entities)
        + Optimize read performance với denormalized data
        + Event sourcing với Kafka
      - Ví dụ:
        Command: CreateStudentCommand, UpdateStudentCommand
        Query: StudentQueryService (có thể dùng Redis cache)
      - Lợi ích: Scale read/write independently, optimize performance

    9. Command Pattern ⭐⭐⭐⭐
      - Mục đích: Encapsulate requests như objects, hỗ trợ undo/redo
      - Ứng dụng: 
        + Event handling system (đã có nhưng chưa structured)
        + Audit logging (track user actions)
        + Transaction rollback commands
      - Ví dụ:
        interface Command {
            void execute();
            void undo();
        }
        class CreateStudentCommand implements Command { ... }
      - Lợi ích: Queue requests, log operations, undo/redo

    10. Retry Pattern (Đã có @Retryable nhưng có thể improve) ⭐⭐⭐⭐
        - Mục đích: Retry failed operations với exponential backoff
        - Ứng dụng:
          + API calls
          + Database operations
          + Kafka message processing
        - Cải thiện:
          + Exponential backoff strategy
          + Circuit breaker integration
          + Metrics tracking
        - Lợi ích: Resilience, better error handling

  + KHUYẾN NGHỊ ƯU TIÊN THÊM:
    1. Circuit Breaker Pattern (Resilience4j) - RẤT QUAN TRỌNG cho microservices
    2. Specification Pattern - Cho complex filtering logic
    3. CQRS - Nếu có nhiều read operations
    4. State Pattern - Cho entity lifecycle management
    5. Command Pattern - Cho audit logging và undo/redo	


###( Guide Note 169)###
* RECORD TRONG JAVA 17:
  1. KHÁI NIỆM:
  - có nhiều điểm tương đồng với Lombok.
  - Record là một loại class đặc biệt được thiết kế trong java 17
  để tạo các lớp dữ liệu bất biến (immutable data classes).
  -> vì thế không có setter, không có kế thừa
  - Record tự động tạo các phương thức thường dùng
  (constructor, getters, equals, hashCode, toString).
  - không dùng getter mà dùng tên biến để gọi.
  - không cần thêm access modifier ( mặc định là private final ).
  - có thể tùy chỉnh constructor nhưng lúc này java sẽ không tự tạo
  constructor mặc định của record.
  - Record có thể sử dụng validation và Jackson annotations

  2. CÚ PHÁP CƠ BẢN:

     Cú pháp:
     ```
     public record TênRecord(KiểuDữLiệu1 tênTrường1, KiểuDữLiệu2 tênTrường2, ...) {
         // Optional: Custom methods, constructors, static fields
     }
     ```
     
     Ví dụ đơn giản:
     ```java
     public record User(int id, String username, String email) {}
     
     // Sử dụng:
     User user = new User(1, "john", "john@example.com");
     -> lúc này các biến là final.


  3. SO SÁNH RECORD VỚI LOMBOK:
     
     Lombok (@Data, @Getter, @Setter):
     ```java
     @Data
     @AllArgsConstructor
     @NoArgsConstructor
     public class UserDto {
         private Integer userId;
         private String username;
     }
     ```
     
     Record (tương đương):
     ```java
     public record UserDto(Integer userId, String username) {}
     ```
     
     Lợi ích Record so với Lombok:
     - Không cần dependency Lombok
     - Built-in Java feature (không cần annotation processing)
     - Immutable mặc định (an toàn hơn)
     - Code ngắn gọn hơn
     - Performance tốt hơn (không cần bytecode generation)
     
     Hạn chế Record so với Lombok:
     - Không hỗ trợ @Builder (phải tự implement)
     - Không hỗ trợ @Setter (immutable mặc định)
     - Không hỗ trợ @NoArgsConstructor (phải có ít nhất 1 field)
     - Không hỗ trợ custom getter/setter names

  4. RECORD VỚI SPRING BOOT:

      Record DTOs:
        public record CreateUserDto(
            @NotBlank 
            String username,
            String name,
            @NotNull @Min(1) @Max(99) 
            Integer age
            @JsonFormat(pattern = "dd-MM-yyyy")
            LocalDate birthDate
        ) {}
     
     
      Response Wrapper:
        ```java
        public record response<T>(
            int status,
            String message,
            T data
        ) {}

  5. KHI NÀO NÊN DÙNG RECORD:
      
      ✅ NÊN DÙNG RECORD KHI:
      - Tạo DTO (Data Transfer Object) cho API requests/responses
      - Tạo value objects (immutable data carriers)
      - Tạo data classes đơn giản (không có logic phức tạp)
      - Cần immutable objects (thread-safe, an toàn)
      - Muốn giảm boilerplate code
      - Muốn không phụ thuộc vào Lombok
      
      ❌ KHÔNG NÊN DÙNG RECORD KHI:
      - Cần mutable objects (có setter, thay đổi giá trị)
      - Cần Builder pattern (phải tự implement)
      - Cần kế thừa (record là final)
      - Cần instance fields bổ sung (ngoài khai báo record)
      - Cần complex business logic trong class
      - Cần JPA Entity (Entity phải là class, không phải record)
      
      ⚠️ LƯU Ý: JPA Entity KHÔNG thể là record vì:
      - Entity cần mutable (Hibernate cần set fields)
      - Entity cần @Id, @GeneratedValue, @Column, etc. (không tương thích với record)
      - Entity cần proxy để lazy loading (record không hỗ trợ)


###( Guide Note 172)###
* HashMap và ConcurrentHashMap
  - Sử dụng HashMap khi:
    + tối ưu cho Single-threaded application
    + Cần performance tối đa
    + Không cần thread safety
    + Có thể chấp nhận null keys/values
  - Sử dụng ConcurrentHashMap khi:
  + tối ưu cho Multi-threaded application
  + có (CAS) là một atomic operation cho phép thay đổi giá trị chỉ khi giá trị hiện tại khớp với giá trị mong đợi.
  ví dụ Chỉ 1 thread thành công, các thread khác retry nên không dẫn đến overwirite data
  + Cần thread safety : Thread Safety là khả năng của code có thể được sử dụng an toàn bởi
  nhiều thread đồng thời mà không gây ra lỗi hoặc hành vi không mong đợi.
  + Read-heavy workloads
  + Cần high concurrency
  + Không thể chấp nhận null keys/values

    --> sử dụng HashMap trong Single-threaded để tối ưu performance,
    sử dụng ConcurrentHashMap trong Multi-threaded để đảm bảo data không mất, bị lỗi,...

            VD:
  * HashMap (UNSAFE) - Lost Data
     Thread A: map.put("key100", 100)
     Thread B: map.put("key200", 200)
     Cả 2 đều hash đến bucket index 5

     Timeline HashMap:
     Thread A: read table[5] = null
     Thread B: read table[5] = null  (cùng lúc)
     Thread A: write table[5] = node100
     Thread B: write table[5] = node200  (OVERWRITE!)

     Kết quả: "key100" bị mất!
     map.get("key100") = null
     map.get("key200") = 200

  * ConcurrentHashMap (SAFE) - No Lost Data
     Thread A: map.put("key100", 100)
     Thread B: map.put("key200", 200)
     Cả 2 đều hash đến bucket index 5

     Timeline ConcurrentHashMap:
     Thread A: casTabAt(table, 5, null, node100) -> true (thành công)
     Thread B: casTabAt(table, 5, null, node200) -> false (thất bại)

     Thread B retry với synchronized block:
     Thread B: synchronized(node100) {
         // Add node200 vào linked list
         node100.next = node200
    }

     Kết quả: Cả 2 entries đều được lưu!
     map.get("key100") = 100
     map.get("key200") = 200


###( Guide Note 174)###
- Set sẽ bỏ qua phần tử đã tồn tại và trả về false, không thực hiện bất kỳ hành vi nào thêm.

###( Guide Note 176)###
* ArrayList và LinkedList
  - tốc độ truy vấn:
    + ArrayList query qua index nên tốc độ cao, còn LinkedList phải query từ đầu
  - thêm,xóa:
    + khi thêm phần tử mới vào đầu hay giữa danh sách ArrayList phải chuyển các phần tử cũ sang phải để nhường chỗ(index) cho
    phần tử Mới
    + vì mỗi data trong LinkedList chứa luôn vị trí (con trỏ) của node đó, chỉ cần thay đổi vị trí con trỏ của các node để thêm mới

  - thêm nữa là LinkedList nó có thể thay đổi kích thước và thêm/xóa phần tử mà không ảnh hưởng đến các phần tử khác
  - còn ArrayList khi mở rộng (resize) phải tạo 1 list mới và copy + thay đổi index của các phần 
  - LinkedList tự động tạo 2 biến first và last khi khởi tạo danh sách, tự động gắn 2 biến này thành phần tử đầu tiên thêm vào danh sách
  và sẽ tự động gắn lại khi thêm/xóa.

    VD: ArrayList
  [0][1][2][3][4]  <- Thêm vào vị trí 2
      ↓
  [0][1][X][2][3][4]  <- Phải dịch chuyển 2,3,4 sang phải

  // Trước khi thêm X vào vị trí 2
  elementData: [A][B][C][D][E][null][null][null]
  index:        0  1  2  3  4   5    6    7

  // Gọi System.arraycopy
  System.arraycopy(elementData, 2, elementData,  3,      3);
  //                   ↑        ↑        ↑       ↑       ↑
  //                  src     srcPos    dest  destPos  length   
                               (2)              (3)     (3)
  //                   ↑        ↑        ↑       ↑       ↑
  //                  mảng     cắt      dán     dán     độ
  //                   sẽ      tại      vào     vào     dài
  //                  thao    vị trí    mảng    từ       3
  //                  tác       2       cũ     index     3

      VD: LinkedList
  A -> B -> C -> D  <- Thêm X vào giữa B và C
  ↓
  A -> B -> X -> C -> D  <- Chỉ cập nhật con trỏ B.next và C.prev
  (gắn vị trí phía sau B lúc này là C = X và gắn vị trí phía trước C lúc này là B = X).
                  
                  Tạo node mới với thông tin đầy đủ
      Node<E> newNode = new Node<>(current.prev, element, current);
                              ↑        ↑           ↑        ↑
                              prev     B           X        C
      
      // Cập nhật con trỏ
      if (current.prev != null) {
          current.prev.next = newNode;  // B.next = X
      }
      current.prev = newNode;  // C.prev = X

  --> ArrayList tốt cho truy cập ngẫu nhiên và thêm vào cuối
      LinkedList tốt cho thao tác đầu/cuối/giữa và cấu trúc Queue/Stack


###( Guide Note 179)###
* Tại sao spring boot lại tốt nhất hiện tại?
  - Auto-configuration & Starters (quan trọng): Giảm cấu hình rườm rà, "bật là chạy" với spring-boot-starter-*.
    + Có thêm tool tạo project spring boot nhanh : https://start.spring.io/
    + Spring Boot tự đăng ký bean(@Bean , @Service , @RestController) phù hợp.
    + Tự động tạo Bean cho các class trong library trong file pom.
    + có Spring Security filter chain tối thiểu.
    + tự động cấu hình server mặc định ( tomcat ).
    + Web MVC mặc định: DispatcherServlet, message converters (Jackson), static resources.
    + Logging (Logback) và cấu hình level qua properties `logging.*`.
    + DataSource (Hikari) + JdbcTemplate khi có driver JDBC.
    + JPA/Hibernate: EntityManagerFactory, TransactionManager, DDL auto khi thêm starter JPA.
    + Cache abstraction + provider (Caffeine/Redis/Ehcache) khi có dependency phù hợp.
    + Validation: Hibernate Validator, hỗ trợ `@Valid` cho MVC và beans.
    + Scheduling/Async: `TaskScheduler`, `TaskExecutor` khi bật `@EnableScheduling`/`@EnableAsync`.
    + Cấu hình externalized: profiles, `application-*.properties/yaml`, environment binding `@ConfigurationProperties`.
    + CORS, multipart upload, compression, HTTP/2, graceful shutdown theo `server.*` và `spring.mvc.*`.

  - Sẵn sàng cloud-native và observable
    + Tối ưu runtime AOT + GraalVM native image cho startup nhanh, footprint thấp.
    + Đóng gói & cấu hình cloud
    Build OCI image nhanh (buildpacks, layered JAR).
    Externalized config + profiles (application-*.yml, env vars).

  - Cộng đồng và tài nguyên: Kho GitHub của Spring Boot có lượng sao, issue, PR, release rất lớn, phản ánh mức độ sử dụng rộng rãi và hoạt động sôi nổi.
  - Spring Data/Security/Validation/Batch: Xử lý CRUD, bảo mật, validation, batch job theo chuẩn thống nhất, hạn chế code nền.


* new 16/11/2025

###( Guide Note 190)###
** về propagation , isolation.
  * PROPAGATION (Transaction Propagation) - Cách transaction lan truyền giữa các method:
    - Định nghĩa: Quyết định cách transaction hoạt động khi method có @Transactional được gọi từ method khác cũng có @Transactional
    
    - Các loại Propagation:
    1. REQUIRED (Mặc định - Default): không cần phải khai báo 
      + Nếu đã có transaction → tham gia vào transaction đó
      + Nếu chưa có transaction → tạo transaction mới
      + VD: Method A (có @Transactional) gọi Method B (có @Transactional) → B tham gia transaction của A
      + Code: @Transactional(propagation = Propagation.REQUIRED)
      + Use case: 90% trường hợp, dùng khi muốn tất cả operations trong cùng 1 transaction
    
    2. REQUIRES_NEW:
      + Luôn tạo transaction MỚI, bất kể đã có transaction hay chưa
      + Transaction mới độc lập hoàn toàn với transaction cũ
      + Nếu transaction mới rollback → không ảnh hưởng transaction cũ
      + Nếu transaction cũ rollback → transaction mới vẫn commit (đã commit rồi)
      + Code: @Transactional(propagation = Propagation.REQUIRES_NEW)
      + Use case: Logging, audit trail, gửi email/notification (không muốn bị rollback khi main transaction fail)
      + Ví dụ:
        @Service
        public class OrderService {
            @Transactional(propagation = Propagation.REQUIRED)
            public void createOrder(Order order) {
                orderRepo.save(order);  // Trong transaction chính
                logService.logOrder(order);  // Gọi method có REQUIRES_NEW
                // Nếu logService.logOrder() fail → transaction mới rollback
                // Nhưng transaction chính VẪN TIẾP TỤC (không bị ảnh hưởng)
            }
        }
        
        @Service
        public class LogService {
            @Transactional(propagation = Propagation.REQUIRES_NEW)
            public void logOrder(Order order) {
                // Transaction MỚI, độc lập
                // Nếu fail → chỉ rollback transaction này
                logRepo.save(new Log("Order created", order.getId()));
            }
        }
    
    3. NESTED:
      + Tạo "savepoint" trong transaction hiện tại (nếu có)
      + Nếu chưa có transaction → tạo transaction mới (giống REQUIRED)
      + Nếu transaction con rollback → chỉ rollback đến savepoint, transaction cha vẫn tiếp tục
      + Nếu transaction cha rollback → transaction con cũng rollback
      + Code: @Transactional(propagation = Propagation.NESTED)
      + Use case: MySQL không hỗ trợ (chỉ hỗ trợ Oracle, PostgreSQL)
      + Lưu ý: Với MySQL/InnoDB → dùng REQUIRES_NEW thay thế
    
    4. SUPPORTS:
      + Nếu đã có transaction → tham gia vào
      + Nếu chưa có transaction → chạy KHÔNG có transaction
      + Code: @Transactional(propagation = Propagation.SUPPORTS)
      + Use case: Method có thể chạy với hoặc không có transaction (read-only operations)
    
    5. NOT_SUPPORTED:
      + Tạm dừng transaction hiện tại (nếu có)
      + Chạy method KHÔNG có transaction
      + Sau khi method xong → tiếp tục transaction cũ
      + Code: @Transactional(propagation = Propagation.NOT_SUPPORTED)
      + Use case: Gọi code không hỗ trợ transaction (VD: JMS, file I/O)
    
    6. MANDATORY:
      + BẮT BUỘC phải có transaction
      + Nếu chưa có transaction → throw IllegalTransactionStateException
      + Code: @Transactional(propagation = Propagation.MANDATORY)
      + Use case: Đảm bảo method chỉ được gọi trong transaction
    
    7. NEVER:
      + BẮT BUỘC KHÔNG được có transaction
      + Nếu đã có transaction → throw IllegalTransactionStateException
      + Code: @Transactional(propagation = Propagation.NEVER)
      + Use case: Method không được gọi trong transaction (hiếm dùng)

  * ISOLATION (Transaction Isolation Level) - Mức độ cô lập giữa các transaction:
    - Định nghĩa: Quyết định transaction này "nhìn thấy" dữ liệu của transaction khác như thế nào
    
    - Các vấn đề có thể xảy ra (concurrency problems):
    1. Dirty Read: Đọc dữ liệu chưa commit từ transaction khác
      VD: Transaction A update balance = 200 (chưa commit)
          Transaction B đọc balance = 200
          Transaction A rollback → balance = 100
          Transaction B đã dùng dữ liệu sai (200)
    
    2. Non-Repeatable Read: Đọc cùng 1 row 2 lần nhưng giá trị khác nhau
      VD: Transaction A đọc balance = 100
          Transaction B update balance = 200 và commit
          Transaction A đọc lại balance = 200 (khác lần 1)
    
    3. Phantom Read: Đọc cùng 1 query 2 lần nhưng số lượng rows khác nhau
      VD: Transaction A SELECT COUNT(*) FROM orders WHERE status='PENDING' → 5 rows
          Transaction B INSERT INTO orders ... (status='PENDING') và commit
          Transaction A SELECT lại → 6 rows (thêm 1 row)
    
    4. Lost Update: 2 transaction cùng update 1 row, update sau ghi đè update trước
      VD: Transaction A: balance = balance + 50 (từ 100 → 150)
          Transaction B: balance = balance - 30 (từ 100 → 70) - đọc 100 cũ
          Kết quả: balance = 70 (mất update của A)
    
    - Các Isolation Level (từ thấp → cao):
    1. READ_UNCOMMITTED (Level 0):
      + Cho phép: Dirty Read, Non-Repeatable Read, Phantom Read
      + Code: @Transactional(isolation = Isolation.READ_UNCOMMITTED)
      + MySQL: Không hỗ trợ (InnoDB không có level này)
      + Use case: Hiếm dùng, chỉ khi cần performance cao và không quan tâm data consistency
    
    2. READ_COMMITTED (Level 1):
      + Ngăn chặn: Dirty Read
      + Vẫn cho phép: Non-Repeatable Read, Phantom Read
      + Code: @Transactional(isolation = Isolation.READ_COMMITTED)
      + MySQL Default: Đây là default của MySQL (nhưng InnoDB dùng REPEATABLE_READ)
      + Use case: Phù hợp cho hầu hết ứng dụng, cân bằng giữa performance và consistency
    
    3. REPEATABLE_READ (Level 2):
      + Ngăn chặn: Dirty Read, Non-Repeatable Read
      + Vẫn cho phép: Phantom Read (nhưng InnoDB ngăn luôn bằng Next-Key Locking)
      + Code: @Transactional(isolation = Isolation.REPEATABLE_READ)
      + MySQL InnoDB Default: Đây là default của InnoDB
      + Use case: ⭐ KHUYẾN NGHỊ cho hầu hết trường hợp (đã dùng trong project)
      + Cơ chế: Sử dụng MVCC (Multi-Version Concurrency Control)
        - Mỗi transaction có "snapshot" của data tại thời điểm bắt đầu
        - Đọc data từ snapshot, không bị ảnh hưởng bởi transaction khác
        - InnoDB dùng Next-Key Locking để ngăn Phantom Read
    
    4. SERIALIZABLE (Level 3):
      + Ngăn chặn: Tất cả (Dirty Read, Non-Repeatable Read, Phantom Read)
      + Code: @Transactional(isolation = Isolation.SERIALIZABLE)
      + Cơ chế: Lock toàn bộ rows được đọc/ghi → chạy tuần tự (serial)
      + Nhược điểm: Performance thấp nhất (nhiều lock, nhiều blocking)
      + Use case: Chỉ dùng khi cần data consistency tuyệt đối, chấp nhận performance thấp
    
    - So sánh Isolation Levels:
      Level              | Dirty Read | Non-Repeatable | Phantom Read | Performance
      -------------------|------------|----------------|--------------|------------
      READ_UNCOMMITTED   |     ✓      |       ✓        |      ✓       |    Cao nhất
      READ_COMMITTED     |     ✗      |       ✓        |      ✓       |    Cao
      REPEATABLE_READ    |     ✗      |       ✗        |      ✗*      |    Trung bình ⭐
      SERIALIZABLE       |     ✗      |       ✗        |      ✗       |    Thấp nhất
      * InnoDB ngăn Phantom Read bằng Next-Key Locking
    
    - Ví dụ cụ thể với REPEATABLE_READ (đang dùng trong project):
      Database: User(id=1, balance=100)
      
      Transaction A (REPEATABLE_READ):
        BEGIN TRANSACTION
        SELECT balance FROM users WHERE id=1;  → balance = 100 (snapshot tại thời điểm này)
        // Transaction B update balance = 200 và commit
        SELECT balance FROM users WHERE id=1;  → balance = 100 (vẫn đọc từ snapshot, không thấy update của B)
        UPDATE users SET balance=150 WHERE id=1;  → Success
        COMMIT → balance = 150
      
      Transaction B (REPEATABLE_READ):
        BEGIN TRANSACTION
        SELECT balance FROM users WHERE id=1;  → 100 (snapshot riêng)
        UPDATE users SET balance=200 WHERE id=1;  → Success
        COMMIT → balance = 200
        // Nếu commit sau A → balance = 200 (ghi đè)
        // Nếu commit trước A → A vẫn thấy 100 (snapshot), nhưng update sẽ conflict
      
    - Kết hợp Propagation + Isolation trong project:
      @Retryable(value = {OptimisticLockingFailureException.class}, maxAttempts = 3)
      @Transactional(
          rollbackFor = Exception.class,
          isolation = Isolation.REPEATABLE_READ,  // Ngăn dirty read, non-repeatable read
          propagation = Propagation.REQUIRED      // Mặc định, tham gia transaction hiện tại
      )
      public EntityModel update(UpdateEntityModel req) {
          // Code...
      }
    
    - Khi nào dùng Isolation Level nào?
      + REPEATABLE_READ (default InnoDB): ⭐ Dùng cho 90% trường hợp
      + READ_COMMITTED: Dùng khi cần performance cao hơn, chấp nhận non-repeatable read
      + SERIALIZABLE: Chỉ dùng khi cần consistency tuyệt đối (hiếm)
    
    - Lưu ý:
      + Isolation level cao hơn → Performance thấp hơn (nhiều lock hơn)
      + MySQL InnoDB mặc định REPEATABLE_READ đã đủ tốt
      + Kết hợp với Optimistic Locking (@Version) để tránh Lost Update
      + Không nên thay đổi isolation level trừ khi có vấn đề cụ thể về concurrency

    

###( Guide Note 192)###
* SO SÁNH MYSQL VÀ REDIS:

  1. ĐỊNH NGHĨA VÀ MỤC ĐÍCH:
    - MySQL:
      + Relational Database Management System (RDBMS)
      + Lưu trữ dữ liệu persistent (bền vững), có cấu trúc
      + Dùng cho: User data, orders, products, transactions (dữ liệu quan trọng)
      + Đảm bảo ACID (Atomicity, Consistency, Isolation, Durability)
    
    - Redis:
      + In-Memory Data Structure Store (NoSQL)
      + Lưu trữ dữ liệu tạm thời trong RAM (nhanh nhưng mất khi restart)
      + Dùng cho: Cache, session storage, rate limiting, real-time data
      + Không đảm bảo ACID (không phải database chính)

  2. KIẾU DỮ LIỆU:
    - MySQL:
      + Relational (bảng, cột, rows)
      + Có foreign keys, relationships
      + Schema rõ ràng (phải định nghĩa trước)
      + VD: Users table, Orders table, Products table
    
    - Redis:
      + Key-Value store (đơn giản nhất)
      + Các data structures: String, Hash, List, Set, Sorted Set
      + Không có schema (flexible)
      + VD: "user:123" → User object, "cache:students" → List<Student>

  3. PERSISTENCE (ĐỘ BỀN):
    - MySQL:
      + Lưu trên disk (persistent)
      + Dữ liệu không mất khi restart server
      + Backup/restore dễ dàng
      + Phù hợp cho dữ liệu quan trọng
    
    - Redis:
      + Mặc định: Chỉ lưu trong RAM (volatile)
      + Có thể config persistence (RDB snapshot, AOF log) nhưng không đảm bảo 100%
      + Dữ liệu có thể mất khi restart (nếu không config persistence)
      + Phù hợp cho dữ liệu tạm thời, có thể tái tạo

  4. PERFORMANCE:
    - MySQL:
      + Chậm hơn Redis (đọc/ghi từ disk)
      + Query phức tạp có thể chậm (JOIN, GROUP BY)
      + Tối ưu bằng index
      + Latency: ~1-10ms (tùy query)
    
    - Redis:
      + Rất nhanh (đọc/ghi từ RAM)
      + Operations đơn giản, atomic
      + Latency: ~0.1-1ms
      + Throughput: 100,000+ ops/sec

  5. QUERY LANGUAGE:
    - MySQL:
      + SQL (Structured Query Language)
      + Phức tạp: SELECT, JOIN, GROUP BY, HAVING, subqueries
      + VD: SELECT u.*, o.total FROM users u JOIN orders o ON u.id = o.user_id
    
    - Redis:
      + Commands (không phải SQL)
      + Đơn giản: GET, SET, INCR, HSET, LPUSH, SADD
      + VD: GET user:123, SET cache:students "data", INCR rate:limit:ip

  6. TRANSACTIONS:
    - MySQL:
      + Hỗ trợ đầy đủ transactions (ACID)
      + @Transactional trong Spring Boot
      + Rollback khi có lỗi
      + Isolation levels (READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE)
    
    - Redis:
      + Có transactions nhưng không đảm bảo ACID
      + MULTI/EXEC commands
      + Không có rollback thực sự
      + Atomic operations (INCR, DECR, SETNX)

  7. SCALABILITY:
    - MySQL:
      + Vertical scaling (tăng RAM, CPU)
      + Horizontal scaling khó (replication, sharding phức tạp)
      + Master-Slave replication
    
    - Redis:
      + Cả vertical và horizontal scaling
      + Redis Cluster (sharding tự động)
      + Master-Slave replication
      + Dễ scale hơn MySQL

  8. USE CASES TRONG PROJECT:
    - MySQL (Dữ liệu chính):
      + UserEntity, StudentEntity, TeacherEntity
      + Dữ liệu quan trọng, cần persistent
      + Quan hệ giữa các bảng (foreign keys)
      + Transactions phức tạp
    
    - Redis (Cache/Temporary):
      + Cache danh sách students: redisTemplate.set("STUDENT_CACHE_KEY", students)
      + IP blocking/whitelist: redisTemplate.hasKey("ip:whitelist:" + ip)
      + Rate limiting: redisTemplate.opsForValue().increment("rate:limit:" + ip)
      + Session storage (nếu dùng)
      + Real-time data (counters, leaderboards)

  9. KẾT HỢP MYSQL + REDIS (Pattern phổ biến):
    - Cache-Aside Pattern:
      1. Check Redis cache trước
      2. Nếu có → return từ cache
      3. Nếu không → query MySQL
      4. Lưu kết quả vào Redis
      5. Return data
    
    - Ví dụ trong project:
      @Override
      public List<EntityModel> gets() {
          // 1. Check Redis cache
          Object cached = redisTemplate.opsForValue().get(STUDENT_CACHE_KEY);
          if (cached != null) {
              return (List<EntityModel>) cached;  // Return từ cache
          }
          
          // 2. Query MySQL
          List<StudentEntity> students = studentRepo.findAll();
          List<EntityModel> models = convertToModels(students);
          
          // 3. Save to Redis
          redisTemplate.opsForValue().set(STUDENT_CACHE_KEY, models);
          
          return models;
      }

  10. KHI NÀO DÙNG MYSQL, KHI NÀO DÙNG REDIS:
    - Dùng MySQL khi:
      + Dữ liệu quan trọng, cần persistent
      + Cần relationships, foreign keys
      + Cần transactions phức tạp
      + Cần query phức tạp (JOIN, GROUP BY)
      + Dữ liệu không thay đổi thường xuyên
    
    - Dùng Redis khi:
      + Cần performance cao (đọc nhanh)
      + Dữ liệu tạm thời, có thể tái tạo
      + Cache để giảm load MySQL
      + Rate limiting, session storage
      + Real-time counters, leaderboards
      + Dữ liệu thay đổi thường xuyên

  11. BẢNG SO SÁNH TỔNG QUAN:
    Tiêu chí          | MySQL                    | Redis
    ------------------|--------------------------|--------------------------
    Loại              | RDBMS (Relational)       | NoSQL (Key-Value)
    Storage           | Disk (persistent)        | RAM (volatile)
    Data Model        | Tables, Rows, Columns    | Key-Value, Data Structures
    Query Language    | SQL                     | Commands (GET, SET, etc.)
    Performance       | Chậm hơn (~1-10ms)      | Nhanh hơn (~0.1-1ms)
    Transactions      | ACID đầy đủ             | Không đảm bảo ACID
    Persistence       | Luôn persistent         | Cần config (RDB/AOF)
    Use Case          | Dữ liệu chính           | Cache, temporary data
    Scalability       | Khó scale horizontal    | Dễ scale horizontal
    Complexity        | Phức tạp (JOIN, etc.)   | Đơn giản (key-value)

  12. BEST PRACTICES:
    - MySQL:
      + Dùng cho dữ liệu chính, quan trọng
      + Luôn có backup strategy
      + Tối ưu queries với index
      + Dùng connection pooling (HikariCP)
      + Monitor slow queries
    
    - Redis:
      + Dùng cho cache, không phải database chính
      + Set TTL (Time To Live) cho cache
      + Monitor memory usage
      + Có strategy khi Redis down (fallback to MySQL)
      + Không lưu dữ liệu quan trọng chỉ trong Redis

  13. VÍ DỤ CỤ THỂ TRONG PROJECT:
    - MySQL:
      + UserEntity → Lưu thông tin user (username, password, role)
      + StudentEntity → Lưu thông tin student (userId, graduate)
      + Quan hệ: UserEntity có thể có StudentEntity hoặc TeacherEntity
    
    - Redis:
      + Cache students list: "STUDENT_CACHE_KEY" → List<EntityModel>
      + IP whitelist: "ip:whitelist:192.168.1.1" → "true"
      + Rate limiting: "rate:limit:192.168.1.1" → counter
      + Delete cache khi update: redisTemplate.delete("STUDENT_CACHE_KEY")

  14. KẾT LUẬN:
    - MySQL và Redis BỔ SUNG cho nhau, không thay thế
    - MySQL: Database chính, lưu dữ liệu persistent
    - Redis: Cache layer, tăng performance, giảm load MySQL
    - Pattern: MySQL (source of truth) + Redis (cache layer) = High performance system



###( Guide Note 194)###
* SO SÁNH JPA VÀ HIBERNATE:

    1. ĐỊNH NGHĨA:
    - JPA (Java Persistence API):
        + Là một SPECIFICATION (đặc tả kỹ thuật)
        + Định nghĩa các interface, annotation, và cách làm việc với database
        + KHÔNG phải implementation (không phải code thực thi)
        + Giống như "bản thiết kế" của một ngôi nhà
    
    - Hibernate:
        + Là một IMPLEMENTATION của JPA specification
        + Code thực thi, làm việc thực sự với database
        + Giống như "ngôi nhà thực tế" được xây theo bản thiết kế
        + Có thể dùng độc lập (không cần JPA) hoặc implement JPA

    2. MỐI QUAN HỆ:
    - JPA = Interface/Specification (như "contract")
    - Hibernate = Implementation (code thực thi)
    - Tương tự như: List (interface) và ArrayList (implementation)
    
    - Ví dụ:
        JPA: "Phải có method save(), findById(), delete()"
        Hibernate: Code thực thi các method đó

    3. JPA SPECIFICATION BAO GỒM:
    - Annotations:
        + @Entity, @Table, @Id, @GeneratedValue
        + @Column, @OneToMany, @ManyToOne, @ManyToMany
        + @Version, @Transient, @Temporal
    
    - Interfaces:
        + EntityManager (quản lý entities)
        + EntityManagerFactory (tạo EntityManager)
        + Query, TypedQuery (thực thi queries)
        + Criteria API (type-safe queries)
    
    - Entity Lifecycle:
        + Persist, Merge, Remove, Refresh, Detach
        + Transaction management

    4. HIBERNATE IMPLEMENTATION:
    - Implement tất cả JPA specification
    - Thêm nhiều tính năng riêng:
        + Hibernate-specific annotations (@Immutable, @NaturalId)
        + Hibernate Session API (bên cạnh JPA EntityManager)
        + HQL (Hibernate Query Language) - mạnh hơn JPQL
        + Native SQL support
        + Caching (first-level, second-level)
        + Lazy loading, Eager loading
        + Connection pooling

    5. TRONG PROJECT CỦA BẠN:
    - JPA Annotations (từ jakarta.persistence):
        @Entity
        @Table(name = "Students")
        public class StudentEntity {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Integer id;
            
            @Version
            private Long version;
        }
        → Đây là JPA specification
    
    - Spring Data JPA (sử dụng JPA):
        public interface StudentRepo extends JpaRepository<StudentEntity, Integer> {
            Optional<StudentEntity> findByUserId(Integer userId);
        }
        → Spring Data JPA dùng JPA specification
    
    - Hibernate (implementation thực tế):
        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
        → Hibernate là implementation thực thi JPA

    6. CÁCH HOẠT ĐỘNG:
    - Khi bạn dùng Spring Data JPA:
        1. Bạn viết code theo JPA specification (annotations, interfaces)
        2. Spring Data JPA sử dụng JPA EntityManager
        3. Hibernate (implementation) thực thi các operations
        4. Hibernate generate SQL và execute trên database
    
    - Flow:
        Code (JPA annotations) 
        → Spring Data JPA (JPA EntityManager)
        → Hibernate (implementation)
        → SQL queries
        → MySQL Database

    7. CÓ THỂ DÙNG HIBERNATE KHÔNG CẦN JPA:
    - Có! Hibernate có thể dùng độc lập:
        + Hibernate Session API (thay vì EntityManager)
        + HQL (thay vì JPQL)
        + Hibernate-specific annotations
    
    - Nhưng trong Spring Boot, thường dùng JPA (chuẩn) và Hibernate là implementation

    8. CÁC IMPLEMENTATION KHÁC CỦA JPA:
    - Hibernate (phổ biến nhất, mạnh nhất)
    - EclipseLink (Oracle)
    - OpenJPA (Apache)
    - DataNucleus
    
    - Tất cả đều implement JPA specification, có thể thay thế nhau

    9. SO SÁNH CHI TIẾT:
    - JPA:
        + Specification (interface)
        + Chuẩn Java EE/Jakarta EE
        + Portable (có thể đổi implementation)
        + Ít tính năng hơn (chỉ specification)
        + Dùng annotations từ jakarta.persistence.*
    
    - Hibernate:
        + Implementation (code thực thi)
        + Mạnh mẽ, nhiều tính năng
        + Có thể dùng độc lập hoặc implement JPA
        + Nhiều tính năng riêng (HQL, caching, etc.)
        + Dùng annotations từ org.hibernate.annotations.*

    10. VÍ DỤ CỤ THỂ:
        - JPA Specification:
        @Entity
        @Table(name = "users")
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        }
        → Bất kỳ JPA implementation nào cũng hiểu
        
        - Hibernate Implementation:
        Khi bạn gọi: userRepo.save(user)
        → Spring Data JPA (JPA layer)
        → Hibernate (implementation)
        → SQL: INSERT INTO users (...) VALUES (...)
        → MySQL execute

    11. SPRING DATA JPA:
        - Spring Data JPA là abstraction layer trên JPA
        - Giúp giảm boilerplate code
        - Tự động implement repository methods
        - Vẫn dùng JPA specification, Hibernate là implementation
        
        - Ví dụ:
        public interface StudentRepo extends JpaRepository<StudentEntity, Integer> {
            // Chỉ cần khai báo method signature
            Optional<StudentEntity> findByUserId(Integer userId);
            // Spring Data JPA tự động implement
            // → Sử dụng JPA EntityManager
            // → Hibernate thực thi
        }

    12. KHI NÀO DÙNG JPA, KHI NÀO DÙNG HIBERNATE:
        - Dùng JPA (specification) khi:
        + Muốn code portable (có thể đổi implementation)
        + Muốn tuân theo chuẩn Java
        + Làm việc với Spring Data JPA
        + Muốn code dễ maintain
        
        - Dùng Hibernate trực tiếp khi:
        + Cần tính năng đặc biệt của Hibernate
        + Cần HQL (Hibernate Query Language)
        + Cần Hibernate Session API
        + Tối ưu performance với Hibernate-specific features

    13. BẢNG SO SÁNH:
        Tiêu chí          | JPA                          | Hibernate
        ------------------|------------------------------|--------------------------
        Loại              | Specification (Interface)    | Implementation (Code)
        Mục đích          | Định nghĩa "làm thế nào"     | Thực thi "làm như thế"
        Annotations       | jakarta.persistence.*        | org.hibernate.annotations.*
        Query Language    | JPQL (Java Persistence QL)   | HQL (Hibernate QL)
        API               | EntityManager                | Session
        Portable          | Có (đổi được implementation) | Không (specific Hibernate)
        Tính năng         | Cơ bản (theo spec)           | Nhiều (ngoài spec)
        Spring Boot       | Dùng qua Spring Data JPA     | Implementation mặc định

    14. TRONG PROJECT CỦA BẠN:
        - Dependencies:
        spring-boot-starter-data-jpa
        → Bao gồm: JPA API + Hibernate implementation
        
        - Configuration:
        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
        → Cấu hình Hibernate (implementation)
        
        - Code:
        @Entity, @Table, @Id → JPA annotations
        JpaRepository → Spring Data JPA (dùng JPA)
        Hibernate thực thi → Generate SQL → MySQL

    15. KẾT LUẬN:
        - JPA và Hibernate KHÔNG phải đối thủ, mà là specification và implementation
        - JPA: "Bản thiết kế" (specification)
        - Hibernate: "Ngôi nhà thực tế" (implementation)
        - Trong Spring Boot: Dùng JPA specification, Hibernate là implementation mặc định
        - Pattern: Code (JPA) → Spring Data JPA → Hibernate → SQL → Database
        - Không cần chọn giữa JPA và Hibernate, dùng cả 2 (JPA spec + Hibernate impl)



###( Guide Note 196)###
* CÁC CACHE LEVELS TRONG HIBERNATE:

  1. TỔNG QUAN:
    - Hibernate có 3 loại cache:
      1. First-Level Cache (Session Cache) - Mặc định, luôn bật
      2. Second-Level Cache (SessionFactory Cache) - Tùy chọn, cần config
      3. Query Cache - Tùy chọn, cần config
    
    - Mục đích: Giảm số lần query database, tăng performance

  2. FIRST-LEVEL CACHE (Session Cache):
    - Định nghĩa:
      + Cache trong phạm vi một Hibernate Session (EntityManager)
      + Tự động bật, không cần config
      + Scope: Chỉ trong một transaction/session
      + Mất khi session đóng
    
    - Cách hoạt động:
      + Khi query entity lần đầu → Lưu vào cache
      + Query cùng entity lần 2 → Lấy từ cache (không query DB)
      + Chỉ áp dụng trong cùng một session
    
    - Ví dụ:
      @Transactional
      public void example() {
          // Lần 1: Query database
          StudentEntity s1 = studentRepo.findById(1).get();
          // SQL: SELECT * FROM Students WHERE id = 1
          
          // Lần 2: Lấy từ First-Level Cache (không query DB)
          StudentEntity s2 = studentRepo.findById(1).get();
          // KHÔNG có SQL query → Lấy từ cache
          
          // s1 và s2 là cùng một object instance (identity)
          assert s1 == s2;  // true
      }
    
    - Đặc điểm:
      + Tự động, không cần config
      + Scope: Một session/transaction
      + Mất khi session đóng
      + Không share giữa các sessions
      + Giúp tránh duplicate queries trong cùng session

  3. SECOND-LEVEL CACHE (SessionFactory Cache):
    - Định nghĩa:
      + Cache ở mức SessionFactory (shared giữa tất cả sessions)
      + Cần config và enable
      + Scope: Toàn bộ application
      + Persist giữa các sessions
    
    - Cách hoạt động:
      + Session 1 query entity → Lưu vào Second-Level Cache
      + Session 2 query cùng entity → Lấy từ Second-Level Cache (không query DB)
      + Share giữa tất cả sessions trong cùng application
    
    - Cấu hình (application.properties):
      # Enable Second-Level Cache
      spring.jpa.properties.hibernate.cache.use_second_level_cache=true
      spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory
      
      # Provider (ví dụ: Ehcache, Hazelcast, Redis)
      # Cần dependency: hibernate-jcache, cache-api
    
    - Enable cho Entity:
      @Entity
      @Cacheable  // Enable Second-Level Cache cho entity này
      @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
      @Table(name = "Students")
      public class StudentEntity {
          // ...
      }
    
    - Cache Concurrency Strategies:
      + READ_ONLY: Chỉ đọc, không update (immutable data)
      + READ_WRITE: Đọc và ghi, dùng version để invalidate
      + NONSTRICT_READ_WRITE: Đọc và ghi, không strict consistency
      + TRANSACTIONAL: Transactional cache (JTA only)
    
    - Ví dụ:
      // Session 1
      @Transactional
      public void session1() {
          StudentEntity s1 = studentRepo.findById(1).get();
          // SQL: SELECT * FROM Students WHERE id = 1
          // → Lưu vào Second-Level Cache
      }
      
      // Session 2 (khác transaction)
      @Transactional
      public void session2() {
          StudentEntity s2 = studentRepo.findById(1).get();
          // KHÔNG có SQL query → Lấy từ Second-Level Cache
      }
    
    - Providers:
      + Ehcache (phổ biến)
      + Hazelcast (distributed)
      + Redis (distributed, external)
      + Infinispan (distributed)
    
    - Lưu ý:
      + Cần config provider
      + Tốn memory (lưu entities trong cache)
      + Cần invalidate khi update/delete
      + Không phù hợp cho data thay đổi thường xuyên

  4. QUERY CACHE:
    - Định nghĩa:
      + Cache kết quả của queries (không phải entities)
      + Cache theo query và parameters
      + Cần enable Second-Level Cache trước
    
    - Cách hoạt động:
      + Query lần 1 với params → Lưu kết quả vào cache
      + Query lần 2 với cùng params → Lấy từ cache
      + Cache key = query + parameters
    
    - Cấu hình:
      # Enable Query Cache
      spring.jpa.properties.hibernate.cache.use_query_cache=true
    
    - Sử dụng:
      @QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))
      @Query("SELECT s FROM StudentEntity s WHERE s.graduate = :graduate")
      List<StudentEntity> findByGraduate(@Param("graduate") Boolean graduate);
    
    - Ví dụ:
      // Lần 1
      List<StudentEntity> list1 = repo.findByGraduate(true);
      // SQL: SELECT * FROM Students WHERE graduate = true
      // → Lưu kết quả vào Query Cache
      
      // Lần 2 (cùng params)
      List<StudentEntity> list2 = repo.findByGraduate(true);
      // KHÔNG có SQL query → Lấy từ Query Cache
      
      // Lần 3 (khác params)
      List<StudentEntity> list3 = repo.findByGraduate(false);
      // SQL: SELECT * FROM Students WHERE graduate = false
      // → Query mới vì params khác
    
    - Lưu ý:
      + Chỉ cache khi dùng @QueryHint với cacheable=true
      + Cache theo query + parameters
      + Cần invalidate khi data thay đổi
      + Không phù hợp cho queries động

  5. SO SÁNH CÁC CACHE LEVELS:
    Tiêu chí          | First-Level      | Second-Level     | Query Cache
    ------------------|------------------|------------------|------------------
    Scope             | 1 Session        | All Sessions     | All Sessions
    Config            | Tự động          | Cần config       | Cần config
    Persist           | Không (mất khi   | Có (giữa         | Có (giữa
                      | session đóng)    | sessions)        | sessions)
    Share             | Không            | Có               | Có
    Cache gì          | Entities         | Entities         | Query results
    Use case          | Tránh duplicate  | Share entities   | Cache queries
                      | trong session    | giữa sessions    | với params

  6. VÍ DỤ TỔNG HỢP:
    @Entity
    @Cacheable
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    public class StudentEntity { ... }
    
    @Repository
    public interface StudentRepo extends JpaRepository<StudentEntity, Integer> {
        @QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))
        @Query("SELECT s FROM StudentEntity s WHERE s.graduate = :graduate")
        List<StudentEntity> findByGraduate(@Param("graduate") Boolean graduate);
    }
    
    // Flow khi query:
    // 1. Check First-Level Cache (trong session hiện tại)
    // 2. Check Second-Level Cache (nếu có)
    // 3. Check Query Cache (nếu query có cacheable)
    // 4. Query database nếu không có trong cache

  7. KHI NÀO DÙNG CACHE NÀO:
    - First-Level Cache:
      + Luôn dùng (tự động)
      + Không cần config
      + Giúp tránh duplicate queries trong cùng transaction
    
    - Second-Level Cache:
      + Dùng khi: Data ít thay đổi, đọc nhiều
      + Ví dụ: Reference data, configuration, lookup tables
      + Không dùng khi: Data thay đổi thường xuyên, cần real-time
    
    - Query Cache:
      + Dùng khi: Query cố định, params ít thay đổi
      + Ví dụ: Reports, dashboards, static queries
      + Không dùng khi: Queries động, params thay đổi nhiều

  8. INVALIDATION (XÓA CACHE):
    - Khi update/delete entity:
      + First-Level Cache: Tự động invalidate trong session
      + Second-Level Cache: Cần config strategy (READ_WRITE tự động invalidate)
      + Query Cache: Cần invalidate thủ công hoặc dùng timestamp
    
    - Cách invalidate:
      @CacheEvict(value = "StudentEntity", allEntries = true)
      public void updateStudent(StudentEntity student) {
          studentRepo.save(student);
          // → Invalidate Second-Level Cache cho StudentEntity
      }

  9. BEST PRACTICES:
    - First-Level Cache:
      + Luôn dùng (tự động)
      + Không cần quan tâm
    
    - Second-Level Cache:
      + Chỉ cache entities ít thay đổi
      + Monitor memory usage
      + Dùng READ_WRITE strategy cho most cases
      + Invalidate khi cần
    
    - Query Cache:
      + Chỉ cache queries cố định
      + Monitor cache hit rate
      + Invalidate khi data thay đổi
    
    - Lưu ý:
      + Cache không phải lúc nào cũng tốt
      + Cần balance giữa performance và memory
      + Monitor cache statistics

  10. TRONG PROJECT CỦA BẠN:
      - Hiện tại: Chưa config Hibernate cache
      - Đang dùng: Redis cache (application-level)
      - Có thể thêm: Second-Level Cache cho entities ít thay đổi
      
      - So sánh Redis Cache vs Hibernate Cache:
        Redis Cache:
          + Application-level (không phụ thuộc Hibernate)
          + Có thể share giữa nhiều applications
          + External (cần Redis server)
          + Flexible (cache bất kỳ data gì)
        
        Hibernate Cache:
          + ORM-level (tích hợp với Hibernate)
          + Chỉ trong một application
          + Internal (trong JVM hoặc external provider)
          + Chỉ cache entities/queries

  11. KẾT LUẬN:
      - First-Level Cache: Tự động, luôn có, scope một session
      - Second-Level Cache: Cần config, share giữa sessions, cho entities
      - Query Cache: Cần config, cache query results, cho queries
      - Pattern: First-Level (auto) + Second-Level (optional) + Query Cache (optional)
      - Redis Cache: Application-level, khác với Hibernate cache



###( Guide Note 198)###
* SO SÁNH SINGLE NODE REDIS VÀ MULTI NODE REDIS:

  1. SINGLE NODE REDIS:
    - Định nghĩa:
      + Chỉ có 1 Redis server instance
      + Tất cả data lưu trên 1 server
      + Đơn giản, dễ setup
    
    - Cấu hình trong project (hiện tại):
      @Bean
      public RedissonClient redisson() {
          Config config = new Config();
          config.useSingleServer()
                  .setAddress("redis://127.0.0.1:6379");
          return Redisson.create(config);
      }
    
    - Ưu điểm:
      + Đơn giản: Chỉ cần 1 server
      + Dễ setup: Không cần config phức tạp
      + Chi phí thấp: Chỉ cần 1 server
      + Phù hợp: Development, testing, small applications
      + Latency thấp: Không có network overhead giữa nodes
    
    - Nhược điểm:
      + Single Point of Failure (SPOF): Nếu server die → mất toàn bộ
      + Không có High Availability: Không có backup
      + Không scale được: Giới hạn bởi 1 server
      + Không có data replication: Mất data nếu server die
      + Memory limit: Giới hạn bởi RAM của 1 server

  2. MULTI NODE REDIS:
    - Định nghĩa:
      + Nhiều Redis server instances
      + Data được phân tán hoặc replicate
      + Có High Availability
    
    - Các kiến trúc Multi Node:
      a) Redis Replication (Master-Slave):
          - 1 Master (ghi) + N Slaves (đọc)
          - Master replicate data sang Slaves
          - Nếu Master die → Promote 1 Slave thành Master
          - Use case: Read scaling, backup
      
      b) Redis Sentinel: ( bản nâng cấp của Replication với các sentinel)
          - Monitor Master-Slave setup
          - Tự động failover khi Master die
          - High Availability
          - Use case: Production với HA requirement
      
      c) Redis Cluster: ( Giống như nhiều nhà kho, mỗi nhà kho chỉ lưu một loại hàng ,
                          Hàng được phân loại và đưa vào nhà kho tương ứng )
          - Sharding data across multiple nodes
          - Automatic failover
          - Horizontal scaling
          - Use case: Large scale, distributed cache

  3. REDIS REPLICATION (MASTER-SLAVE):
    - Kiến trúc:
      Master (Write) → Replicate → Slave 1 (Read)
                            → Slave 2 (Read)
                            → Slave 3 (Read)
    
    - Cách hoạt động:
      + Master nhận tất cả write operations
      + Master replicate data sang tất cả Slaves
      + Slaves chỉ đọc (read-only)
      + Client đọc từ Slaves, ghi vào Master
    
    - Cấu hình:
      # Master config (redis.conf)
      # Không cần config đặc biệt
      
      # Slave config (redis.conf)
      replicaof <master-ip> <master-port>
      replica-read-only yes
    
    - Ưu điểm:
      + Read scaling: Nhiều Slaves đọc song song
      + Backup: Slaves là backup của Master
      + High Availability: Có thể promote Slave thành Master
    
    - Nhược điểm:
      + Không scale write: Chỉ 1 Master ghi
      + Replication lag: Slaves có thể lag sau Master
      + Manual failover: Cần promote Slave thủ công

  4. REDIS SENTINEL:
    - Kiến trúc:
      Sentinel 1 ─┐
      Sentinel 2 ─┼─ Monitor → Master ─→ Slaves
      Sentinel 3 ─┘
    
    - Cách hoạt động:
      + Sentinels monitor Master và Slaves
      + Nếu Master die → Sentinels tự động promote 1 Slave thành Master
      + Client connect qua Sentinel (không connect trực tiếp Master)
      + Sentinel tự động redirect đến Master mới
    
    - Cấu hình:
      # Sentinel config (sentinel.conf)
      sentinel monitor mymaster 127.0.0.1 6379 2
      sentinel down-after-milliseconds mymaster 5000
      sentinel failover-timeout mymaster 10000
    
    - Cấu hình trong Spring Boot:
      @Bean
      public RedissonClient redisson() {
          Config config = new Config();
          config.useSentinelServers()
                  .setMasterName("mymaster")
                  .addSentinelAddress("redis://127.0.0.1:26379")
                  .addSentinelAddress("redis://127.0.0.1:26380")
                  .addSentinelAddress("redis://127.0.0.1:26381");
          return Redisson.create(config);
      }

    - Data flow thực tế
      1. Client → Sentinel: "Master ở đâu?"
        Sentinel → Client: "Master ở 127.0.0.1:6379"
      
      2. Client → Master: SET key "value"
        Master → Client: OK
        
      3. Master → Slave 1: Replicate data
        Master → Slave 2: Replicate data
        
      → Sentinel KHÔNG tham gia vào data flow!
      → Sentinel chỉ giúp client tìm Master!
    
    - Ưu điểm:
      + Automatic failover: Tự động khi Master die
      + High Availability: Không có downtime
      + Monitor: Sentinels monitor health
      + Production-ready: Phù hợp cho production
    
    - Nhược điểm:
      + Phức tạp hơn: Cần config Sentinels
      + Vẫn chỉ 1 Master ghi: Không scale write
      + Cần ít nhất 3 Sentinels: Để đảm bảo quorum

  5. REDIS CLUSTER:
    - Kiến trúc:
      Node 1 (Slot 0-5460)    Node 2 (Slot 5461-10922)   Node 3 (Slot 10923-16383)
      Node 4 (Replica of 1)   Node 5 (Replica of 2)     Node 6 (Replica of 3)
    
    - Cách hoạt động:
      + Data được shard thành 16384 slots
      + Mỗi node quản lý một số slots
      + Client tự động route đến node đúng
      + Mỗi node có 1 replica (backup)
      + Automatic failover khi node die
    
    - Cấu hình:
      # Cluster config (redis.conf)
      cluster-enabled yes
      cluster-config-file nodes.conf
      cluster-node-timeout 5000
    
    - Cấu hình trong Spring Boot:
      @Bean
      public RedissonClient redisson() {
          Config config = new Config();
          config.useClusterServers()
                  .addNodeAddress("redis://127.0.0.1:7000")
                  .addNodeAddress("redis://127.0.0.1:7001")
                  .addNodeAddress("redis://127.0.0.1:7002")
                  .addNodeAddress("redis://127.0.0.1:7003")
                  .addNodeAddress("redis://127.0.0.1:7004")
                  .addNodeAddress("redis://127.0.0.1:7005");
          return Redisson.create(config);
      }
    
    - Ưu điểm:
      + Horizontal scaling: Thêm nodes để scale
      + Automatic sharding: Data tự động phân tán
      + Automatic failover: Tự động khi node die
      + High Availability: Mỗi node có replica
      + Scale cả read và write: Nhiều nodes xử lý
    
    - Nhược điểm:
      + Phức tạp nhất: Cần nhiều nodes
      + Multi-key operations: Một số operations không support
      + Chi phí cao: Cần nhiều servers
      + Overhead: Network communication giữa nodes

  6. SO SÁNH CHI TIẾT:
    Tiêu chí          | Single Node    | Replication     | Sentinel       | Cluster
    ------------------|----------------|-----------------|----------------|------------------
    Số nodes          | 1              | 2+ (1M + NS)    | 3+ (1M+NS+3S)  | 6+ (3M+3R)
    High Availability | Không          | Manual          | Automatic      | Automatic
    Failover          | Không          | Manual          | Automatic      | Automatic
    Read Scaling      | Không          | Có (Slaves)     | Có (Slaves)    | Có (All nodes)
    Write Scaling     | Không          | Không           | Không          | Có (Sharding)
    Setup             | Đơn giản       | Trung bình      | Phức tạp       | Rất phức tạp
    Chi phí           | Thấp           | Trung bình      | Trung bình     | Cao
    Use case          | Dev/Test       | Read-heavy      | Production     | Large scale
    Data loss risk    | Cao            | Trung bình      | Thấp           | Rất thấp

  7. KHI NÀO DÙNG CÁI NÀO:
    - Single Node:
      + Development, testing
      + Small applications
      + Không cần High Availability
      + Budget hạn chế
      + Low traffic
    
    - Replication (Master-Slave):
      + Read-heavy applications
      + Cần backup data
      + Có thể chấp nhận manual failover
      + Medium traffic
    
    - Sentinel:
      + Production applications
      + Cần High Availability
      + Cần automatic failover
      + Medium to high traffic
      + Không cần scale write
    
    - Cluster:
      + Large scale applications
      + Cần scale cả read và write
      + Very high traffic
      + Distributed systems
      + Cần horizontal scaling

  8. TRONG PROJECT CỦA BẠN:
    - Hiện tại: Single Node Redis
      config.useSingleServer()
      .setAddress("redis://127.0.0.1:6379");
    
    - Phù hợp cho: Development, testing
    
    - Nếu chuyển sang Production:
      + Nên dùng Sentinel (nếu không cần scale write)
      + Hoặc Cluster (nếu cần scale write )
      + Cần update config trong RedisConfig.java

  9. MIGRATION TỪ SINGLE NODE SANG MULTI NODE:
    - Bước 1: Setup Redis Replication/Sentinel/Cluster
    - Bước 2: Update config trong Spring Boot
    - Bước 3: Test failover scenarios
    - Bước 4: Deploy và monitor
    
    - Ví dụ migration sang Sentinel:
      // Cũ (Single Node)
      config.useSingleServer()
              .setAddress("redis://127.0.0.1:6379");
      
      // Mới (Sentinel)
      config.useSentinelServers()
              .setMasterName("mymaster")
              .addSentinelAddress("redis://127.0.0.1:26379")
              .addSentinelAddress("redis://127.0.0.1:26380")
              .addSentinelAddress("redis://127.0.0.1:26381");

  10. BEST PRACTICES:
      - Development: Single Node (đơn giản)
      - Staging: Replication hoặc Sentinel (test HA)
      - Production: Sentinel hoặc Cluster (HA + scaling)
      - Monitor: Luôn monitor Redis health
      - Backup: Có strategy backup data
      - Testing: Test failover scenarios trước khi deploy

  11. KẾT LUẬN:
      - Single Node: Đơn giản, phù hợp dev/test
      - Replication: Read scaling, backup
      - Sentinel: Production với HA, automatic failover
      - Cluster: Large scale, horizontal scaling
      - Chọn theo: Requirements (HA, scaling, complexity, cost)





















































