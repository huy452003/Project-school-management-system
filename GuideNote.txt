nên dùng enum chỗ gender	 =

thêm method bắt Exception chung		 = 
	
nên throw exception và sử lý trong exceptionhandler 	=

sữa lại kiểu trả về method 	=

sửa lại message của validate 	= 

* yêu cầu mới:

- tạo project teacher 				=

- bên teacher cần 1 hàm để lấy dssv		=

- xử lý lỗi nếu bên sv có lỗi khi teacher gọi API của sv ( cả 2 bên ) đã sửa lại

- xử lý đồng bộ dữ liệu ở 2 bên, VD: từ project A gọi sang project B nhưng project
B cập nhật (thêm - xóa) data bị lỗi thì data bên project A phải được rollback về 
như ban đầu.	=

- tìm hiểu các caching (Redis) , và xử lý cho cả 2 project 		=

- cách để đo thời gian chạy của API 					=

*new*

- tìm hiểu cách để log lỗi 1 cách đồng bộ giữa các module ( tao 1 module chuyen 
log errors) 		=

- cách sử dụng redis trong project Springboot ( không sử dụng annotation ) =

- khi thiết kế cả teacher và student cùng 1 project là những module khi deploy 
project thì teacher và student sẽ gọi nhau như thế nào
+ khi này sẽ thêm dependency của student vào teacher , sau đó gọi service từ 
student đến teacher như thường			=	

- tìm hiểu về maven 
+ packaging ( war, jar, pom ) : khái niệm và cách sử dụng
 = war : sử dụng trong spring mvc , ứng dụng web 
 = jar : sử dụng trong project java thông thường
 = pom : sử dụng trong project cha , trong việc quản lý dependency/module 
+ dependencies , dependencyManagerment : trong mối quan hệ project cha con
 = dependencies : dùng để khai báo các thư viện cần dùng trong file pom
 = dependencyManagerment : dùng trong file pom của module cha để quản lý 
version của các dependency dùng chung , và các project con chỉ việc thêm 
dependency từ dependencyManagerment không cần version		=

- tìm hiểu restful Api
+ gồm có status code , các model(DTO) để tách dữ liệu nhận vào và trả về nhằm bảo
mật thông tin ( vd: che dấu password khi lấy dữ liệu từ database )
, chuyển sang kiểu dữ liệu JSON ( dễ dùng , nhẹ hơn kiểu xml ) 		=

- tìm hiểu docker, docker images, docker compose : những công dụng của chúng  =

- so sánh giữa 2 cách sử dụng annotation và redis trong caching		=

- không nên để tên HttpMethod vào url				=

*new 10/8/2025*

- tạo 1 security module 	=
+ thiết kế database user , role		=
+ tại postman truyền vào js userName, password		=
+ từ userName và password này tạo 1 JWToken 		=
+ những API khác như get, post, put, delete phải có Token mới được truy cập
nếu không được phép trả về lỗi 401		=
+ cấu hình những đường dẫn truy cập trực tiếp không cần xác thực và ngược lại	=

- bên trong JWToken có những phần gì? giải thích cụ thể 		=
* gồm ba phần : header , payload , signature
+ header : gồm thuật toán mã hóa và loại token ( thường là JWT )
+ payload ( thân ) : chứa các claims -> 1 claim là 1 thông tin của user, có 2 dạng là:
claim chuẩn gồm : userID , thời gian tạo, thời gian hết hạn , còn dạng nữa là
custom claim do ta tự định nghĩa và có thêm như : role ( vai trò )
, permiss ( quyền hạn ), email,  ... 
+ signature : được tạo bằng cách mã hóa header và payload và mã hóa chúng bằng secret key 
nhằm bảo mật tránh việc bị làm giả token
- thường đi chung với bearer token để tăng tính rõ ràng và chuẩn hóa RFC
 
- cách để tạo 1 Token? Cách thu hồi? phải gắn permision trong Token		=

* JWT token không thể thu hồi trực tiếp nhưng có nhiều cách để xử lý như :
+ lưu token vào database và revoke
+ thêm token vào blacklist và block khi sử dụng nó , khi token hết hạn sẽ tự mất

- cách giải mã Token		=

- nếu Token hết hạn thì giải quyết như thế nào?			=
+ access token tự động xóa khi hết hạn
+ sử dụng refresh token để tạo access token mới mà không cần phải đăng nhập lại

JWT và Session trong restful API
- session cần query database , jwt không cần -> tăng hiệu suất
- rest API không cần lưu trạng thái resquest nên session không phù hợp


* messaging. kafka : gửi message từ bên nói ( gửi ) sang bên nghe ( nhận )
- có các cụm broker : gồm các kafka-broker : chứa các metadata 
- metadata có : 
+ topic : nội dung message ( get, save, ... )
+ các partition : chia nhỏ topic, nội dung đi theo tuần từ. vd: parition 1 : 0,1,2,3,4
+ offset : khoảng partition ( nội dung đẫ chia nhỏ ) đã đi được. vd: partition đã đi
được 3 phần -> offset = 3
- kết nối với các zookeeper để quản lý các broker
+ các zookeeper sẽ có 1 zookeeper trưởng có quyền ghi và các zookeeper khác sẽ có quyền đọc

--> ở bản mới nhất của kafka (>3.3.0) đã hỗ trợ KRaft mode, không cần dùng Zookeeper nữa vì:
Cũ (Zookeeper): Kafka lưu metadata cluster (topic, partition, ACL, v.v.) trong Zookeeper.
Mới (KRaft): Metadata lưu trực tiếp trong Kafka Controller, sử dụng Raft consensus.

** --> bản chất của kafka là để message từ producer sang các consumer thông qua các topic

*new-28/09/2025

- tìm hiểu cách phân trang.		=

- làm 1 api filter (tìm từng ký tự) cho phép filter theo nhiều đk cùng lúc, còn search chỉ cho phép 1 đk 1 lúc.     =

- database user nằm ở database khác với data của student khi login xong thì làm sao để xác định student vừa login là ai,
    tôi có ý tưởng là sẽ dung kafka để gửi event cho endpoint main của student và trả data ngay lập tức.
+ cho thêm 1 biến userName để khớp với lại data bên security.
+ không nên gọi API khi xử lý message Kafka chỉ nên gọi service xử lý.

- tại thời điểm xác thực user thành công ở authFilter thì có gửi thêm data (không nhạy cảm) sang endpoint ở service khác không?
+ có thể : nhưng chỉ nên gửi các bất đồng bộ như kafka message tránh làm chậm response.
 * làm thêm phần nhận userEvent của các module.


- tìm hiểu lại cách làm lại luồng đi của security và các module khác.
+ thay interceptor bằng cách sử dụng AOP , custom annotation để check JWT các method cần 
bảo vệ , nhưng method không sử dụng annotation thì được xem là public API


- xử lý khi consumer nhận message thất bại và thành công thì producer có biết được trạng thái của message không?,
  nếu producer là 1 project frontEnd thì sao liệu producer có thể là project frontEnd?
  
+ gửi notification topic khi xử lý message và producer sẽ Listen topic notification
, phân loại ra và biết được trạng thái message.

+  nếu producer là 1 project frontEnd thì có thể nhưng không nên vì :
    - vấn đề bảo mật
    - vấn đề performance
    - nên frontEnd chỉ nền giao tiếp với backEnd qua rest API



* new 26/10/2025, phạm vi : (Spring boot và MySQL).

- ss giữa AOP(module security_shared) và SecurityConfig(module security) tôi đã cấu hình.    =     
để tránh duplicate.       

- Nếu như có 1000 req gửi cùng lúc trong 1s và gửi liên tục trong 5s thì làm cách nào 	  =
để bảo vệ API, khi mà service die phải làm cách nào để khôi phục ser ngay.	
( tìm giải pháp để bảo vệ API trong tình huống trên và khắc phục hậu quả khi ser die ).

- lý thuyết + thực hành.
1/ nghiên cứu vấn đề n+1 trong db, cho ví dụ và giải pháp để giải quyết.     =

2/ các loại index trong db. Làm ví dụ từng loại và nêu lợi ích, tác hại của nó.       =

3/ ( cả MySQL và Redis ) xử lý nếu như cùng 1 thời điểm mà có 2 câu lệnh update data thì nên    =
làm gì để tránh data không đồng bộ. Khi nào sẽ áp dụng ở redis (Spring boot), MySql (Spring boot).

4/ liệt kê các design pattern tôi đang dùng trong projcet hiện tại và hãy giải thích các design này     =
, sau đó gợi ý thêm các design pattern có thể thêm vào được.	

5/ record trong java 17.	=

- lý thuyết.
6/ HashMap và ConcurrentHashMap ss cơ chế bên trong.    =

7/ Set khi thêm 1 phần tử mới nhưng phát hiện đã có trong nó thì Set sẽ không thêm hay remove data cũ thêm mới vô.  =

8/ ArrayList và LinkedList ss tốc độ truy vấn, thêm, xóa    =
hiểu cơ chế hoạt động bên trong.

9/ Tại sao spring boot lại tốt nhất hiện tại? (trả lời + dẫn chứng).    =


** new 16/11/2025 : Demo lại

1/ thêm Rate limiting.                  =

2/ IP blocking/Geo blocking.                 =

3/ thêm Circuit Breaker cho student.               =

4/ tìm hiểu về propagation , isolation.             =

5/ ss giữa Mysql và Redis.                      =

6/ ss giữa Jpa và Hibernate.                     =

7/ tìm hiểu level cache trong Hibernate.             =

8/ tìm hiểu giữa single node redis và multi node redis.         =

** new 7/12/2025:

1/ cách hoạt động của index khi query 'like' trong db, index với 1 số method trong db.           =

2/ viết 1 api để test trường hợp update data đồng thời (2 luồng trở lên) để giả lập tình huống      =
từ 2 req update cùng lúc 1 user_id.

3/ sau khi tạo access token sẽ set 1 biến môi trường cho token đó để sử dụng cho api tiếp theo.     =

4/ tìm hiểu kĩ lại cơ chế của HashMap và ConcurrentHashMap từ bước insert , update , remove và      =
lý do vì sao ConcurrentHashMap lại hỗ trợ tốt cho multi-threads.
