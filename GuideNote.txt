nên dùng enum chỗ gender	 =

thêm method bắt Exception chung		 = 
	
nên throw exception và sử lý trong exceptionhandler 	=

sữa lại kiểu trả về method 	=

sửa lại message của validate 	= 

* yêu cầu mới:

- tạo project teacher 				=

- bên teacher cần 1 hàm để lấy dssv		=

- xử lý lỗi nếu bên sv có lỗi khi teacher gọi API của sv ( cả 2 bên ) đã sửa lại

- xử lý đồng bộ dữ liệu ở 2 bên, VD: từ project A gọi sang project B nhưng project
B cập nhật (thêm - xóa) data bị lỗi thì data bên project A phải được rollback về 
như ban đầu.	=

- tìm hiểu các caching (Redis) , và xử lý cho cả 2 project 		=

- cách để đo thời gian chạy của API 					=

*new*

- tìm hiểu cách để log lỗi 1 cách đồng bộ giữa các module ( tao 1 module chuyen 
log errors) 		=

- cách sử dụng redis trong project Springboot ( không sử dụng annotation ) =

- khi thiết kế cả teacher và student cùng 1 project là những module khi deploy 
project thì teacher và student sẽ gọi nhau như thế nào
+ khi này sẽ thêm dependency của student vào teacher , sau đó gọi service từ 
student đến teacher như thường			=	

- tìm hiểu về maven 
+ packaging ( war, jar, pom ) : khái niệm và cách sử dụng
 = war : sử dụng trong spring mvc , ứng dụng web 
 = jar : sử dụng trong project java thông thường
 = pom : sử dụng trong project cha , trong việc quản lý dependency/module 
+ dependencies , dependencyManagerment : trong mối quan hệ project cha con
 = dependencies : dùng để khai báo các thư viện cần dùng trong file pom
 = dependencyManagerment : dùng trong file pom của module cha để quản lý 
version của các dependency dùng chung , và các project con chỉ việc thêm 
dependency từ dependencyManagerment không cần version		=

- tìm hiểu restful Api
+ gồm có status code , các model(DTO) để tách dữ liệu nhận vào và trả về nhằm bảo
mật thông tin ( vd: che dấu password khi lấy dữ liệu từ database )
, chuyển sang kiểu dữ liệu JSON ( dễ dùng , nhẹ hơn kiểu xml ) 		=

- tìm hiểu docker, docker images, docker compose : những công dụng của chúng  =

- so sánh giữa 2 cách sử dụng annotation và redis trong caching		=

- không nên để tên HttpMethod vào url				=

*new 10/8/2025*

- tạo 1 security module 	=
+ thiết kế database user , role		=
+ tại postman truyền vào js userName, password		=
+ từ userName và password này tạo 1 JWToken 		=
+ những API khác như get, post, put, delete phải có Token mới được truy cập
nếu không được phép trả về lỗi 401		=
+ cấu hình những đường dẫn truy cập trực tiếp không cần xác thực và ngược lại	=

- bên trong JWToken có những phần gì? giải thích cụ thể 		=
* gồm ba phần : header , payload , signature
+ header : gồm thuật toán mã hóa và loại token ( thường là JWT )
+ payload ( thân ) : chứa các claims -> 1 claim là 1 thông tin của user, có 2 dạng là:
claim chuẩn gồm : userID , thời gian tạo, thời gian hết hạn , còn dạng nữa là
custom claim do ta tự định nghĩa và có thêm như : role ( vai trò )
, permiss ( quyền hạn ), email,  ... 
+ signature : được tạo bằng cách mã hóa header và payload và mã hóa chúng bằng secret key 
nhằm bảo mật tránh việc bị làm giả token
- thường đi chung với bearer token để tăng tính rõ ràng và chuẩn hóa RFC
 
- cách để tạo 1 Token? Cách thu hồi? phải gắn permision trong Token		=

* JWT token không thể thu hồi trực tiếp nhưng có nhiều cách để xử lý như :
+ lưu token vào database và revoke
+ thêm token vào blacklist và block khi sử dụng nó , khi token hết hạn sẽ tự mất

- cách giải mã Token		=

- nếu Token hết hạn thì giải quyết như thế nào?			=
+ access token tự động xóa khi hết hạn
+ sử dụng refresh token để tạo access token mới mà không cần phải đăng nhập lại

JWT và Session trong restful API
- session cần query database , jwt không cần -> tăng hiệu suất
- rest API không cần lưu trạng thái resquest nên session không phù hợp


* messaging. kafka : gửi message từ bên nói ( gửi ) sang bên nghe ( nhận )
- có các cụm broker : gồm các kafka-broker : chứa các metadata 
- metadata có : 
+ topic : nội dung message ( get, save, ... )
+ các partition : chia nhỏ topic, nội dung đi theo tuần từ. vd: parition 1 : 0,1,2,3,4
+ offset : khoảng partition ( nội dung đẫ chia nhỏ ) đã đi được. vd: partition đã đi
được 3 phần -> offset = 3
- kết nối với các zookeeper để quản lý các broker
+ các zookeeper sẽ có 1 zookeeper trưởng có quyền ghi và các zookeeper khác sẽ có quyền đọc

--> ở bản mới nhất của kafka (>3.3.0) đã hỗ trợ KRaft mode, không cần dùng Zookeeper nữa vì:
Cũ (Zookeeper): Kafka lưu metadata cluster (topic, partition, ACL, v.v.) trong Zookeeper.
Mới (KRaft): Metadata lưu trực tiếp trong Kafka Controller, sử dụng Raft consensus.

** --> bản chất của kafka là để message từ producer sang các consumer thông qua các topic

*new-28/09/2025

- tìm hiểu cách phân trang.		=

- làm 1 api filter (tìm từng ký tự) cho phép filter theo nhiều đk cùng lúc, còn search chỉ cho phép 1 đk 1 lúc.     =

- database user nằm ở database khác với data của student khi login xong thì làm sao để xác định student vừa login là ai,
    tôi có ý tưởng là sẽ dung kafka để gửi event cho endpoint main của student và trả data ngay lập tức.
+ cho thêm 1 biến userName để khớp với lại data bên security.
+ không nên gọi API khi xử lý message Kafka chỉ nên gọi service xử lý.

- tại thời điểm xác thực user thành công ở authFilter thì có gửi thêm data (không nhạy cảm) sang endpoint ở service khác không?
+ có thể : nhưng chỉ nên gửi các bất đồng bộ như kafka message tránh làm chậm response

- những cách khác để bảo vệ backend và database ngoài trừ JWToken.
+ Session-based Authentication (Server-side Sessions)
    Khái niệm: Server tạo một session ID sau khi login; ID lưu ở cookie.
    Trạng thái (user, quyền, TTL) lưu trên server (RAM/Redis/DB).
+ API Keys
    Khái niệm: Khóa tĩnh gán cho client (header/query).
    Dùng để nhận diện, đôi khi gắn quota/rate limit.

- tìm hiểu lại cách làm lại luồng đi của security và các module khác.
+ thay interceptor bằng cách sử dụng AOP , custom annotation để check JWT các method cần 
bảo vệ , nhưng method không sử dụng annotation thì được xem là public API

- xử lý khi consumer nhận message thất bại và thành công thì producer có biết được trạng thái của message không?,
  nếu producer là 1 project frontEnd thì sao liệu producer có thể là project frontEnd?
  
+ gửi notification topic khi xử lý message và producer sẽ Listen topic notification
, phân loại ra và biết được trạng thái message.

+  nếu producer là 1 project frontEnd thì có thể nhưng không nên vì :
    - vấn đề bảo mật
    - vấn đề performance
    - nên frontEnd chỉ nền giao tiếp với backEnd qua rest API




		